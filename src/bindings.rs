/* automatically generated by rust-bindgen 0.59.2 */

pub const NO_SYS: u32 = 1;
pub const LWIP_TIMERS: u32 = 0;
pub const MEM_ALIGNMENT: u32 = 4;
pub const LWIP_ARP: u32 = 0;
pub const ARP_QUEUEING: u32 = 0;
pub const IP_FORWARD: u32 = 0;
pub const LWIP_ICMP: u32 = 1;
pub const LWIP_RAW: u32 = 0;
pub const LWIP_DHCP: u32 = 0;
pub const LWIP_AUTOIP: u32 = 0;
pub const LWIP_SNMP: u32 = 0;
pub const LWIP_IGMP: u32 = 0;
pub const LWIP_DNS: u32 = 0;
pub const LWIP_UDP: u32 = 0;
pub const LWIP_UDPLITE: u32 = 0;
pub const LWIP_TCP: u32 = 1;
pub const LWIP_CALLBACK_API: u32 = 1;
pub const LWIP_NETIF_API: u32 = 0;
pub const LWIP_NETIF_LOOPBACK: u32 = 0;
pub const LWIP_HAVE_LOOPIF: u32 = 0;
pub const LWIP_HAVE_SLIPIF: u32 = 0;
pub const LWIP_NETCONN: u32 = 0;
pub const LWIP_SOCKET: u32 = 0;
pub const PPP_SUPPORT: u32 = 0;
pub const LWIP_IPV6: u32 = 1;
pub const LWIP_IPV6_MLD: u32 = 0;
pub const LWIP_IPV6_AUTOCONFIG: u32 = 0;
pub const MEMP_NUM_TCP_PCB_LISTEN: u32 = 16;
pub const MEMP_NUM_TCP_PCB: u32 = 1024;
pub const TCP_MSS: u32 = 1460;
pub const TCP_SND_BUF: u32 = 16384;
pub const TCP_SND_QUEUELEN: u32 = 44;
pub const MEM_LIBC_MALLOC: u32 = 1;
pub const MEMP_MEM_MALLOC: u32 = 1;
pub const LWIP_PERF: u32 = 0;
pub const SYS_LIGHTWEIGHT_PROT: u32 = 0;
pub const IPV6_FRAG_COPYHEADER: u32 = 1;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const BYTE_ORDER: u32 = 1234;
pub const __BIONIC__: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __bos_level: u32 = 0;
pub const __ANDROID_API_FUTURE__: u32 = 10000;
pub const __ANDROID_API__: u32 = 10000;
pub const __ANDROID_API_G__: u32 = 9;
pub const __ANDROID_API_I__: u32 = 14;
pub const __ANDROID_API_J__: u32 = 16;
pub const __ANDROID_API_J_MR1__: u32 = 17;
pub const __ANDROID_API_J_MR2__: u32 = 18;
pub const __ANDROID_API_K__: u32 = 19;
pub const __ANDROID_API_L__: u32 = 21;
pub const __ANDROID_API_L_MR1__: u32 = 22;
pub const __ANDROID_API_M__: u32 = 23;
pub const __ANDROID_API_N__: u32 = 24;
pub const __ANDROID_API_N_MR1__: u32 = 25;
pub const __ANDROID_API_O__: u32 = 26;
pub const __ANDROID_API_O_MR1__: u32 = 27;
pub const __ANDROID_API_P__: u32 = 28;
pub const __ANDROID_API_Q__: u32 = 29;
pub const __ANDROID_API_R__: u32 = 30;
pub const __ANDROID_API_S__: u32 = 31;
pub const __ANDROID_API_T__: u32 = 33;
pub const __ANDROID_NDK__: u32 = 1;
pub const __NDK_MAJOR__: u32 = 24;
pub const __NDK_MINOR__: u32 = 0;
pub const __NDK_BETA__: u32 = 0;
pub const __NDK_BUILD__: u32 = 8215888;
pub const __NDK_CANARY__: u32 = 0;
pub const WCHAR_MIN: u8 = 0u8;
pub const INT8_MIN: i32 = -128;
pub const INT8_MAX: u32 = 127;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST8_MAX: u32 = 127;
pub const UINT8_MAX: u32 = 255;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_FAST8_MAX: u32 = 255;
pub const INT16_MIN: i32 = -32768;
pub const INT16_MAX: u32 = 32767;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const UINT16_MAX: u32 = 65535;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const INT32_MIN: i32 = -2147483648;
pub const INT32_MAX: u32 = 2147483647;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 4294967295;
pub const WINT_MIN: u32 = 0;
pub const __BITS_PER_LONG: u32 = 64;
pub const __FD_SETSIZE: u32 = 1024;
pub const __GNUC_VA_LIST: u32 = 1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const EOF: i32 = -1;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 4096;
pub const L_tmpnam: u32 = 4096;
pub const TMP_MAX: u32 = 308915776;
pub const P_tmpdir: &[u8; 6usize] = b"/tmp/\0";
pub const L_ctermid: u32 = 1024;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const P_ALL: u32 = 0;
pub const P_PID: u32 = 1;
pub const P_PGID: u32 = 2;
pub const P_PIDFD: u32 = 3;
pub const STRUCT_MALLINFO_DECLARED: u32 = 1;
pub const M_DECAY_TIME: i32 = -100;
pub const M_PURGE: i32 = -101;
pub const M_MEMTAG_TUNING: i32 = -102;
pub const M_MEMTAG_TUNING_BUFFER_OVERFLOW: u32 = 0;
pub const M_MEMTAG_TUNING_UAF: u32 = 1;
pub const M_THREAD_DISABLE_MEM_INIT: i32 = -103;
pub const M_CACHE_COUNT_MAX: i32 = -200;
pub const M_CACHE_SIZE_MAX: i32 = -201;
pub const M_TSDS_COUNT_MAX: i32 = -202;
pub const M_BIONIC_ZERO_INIT: i32 = -203;
pub const M_BIONIC_SET_HEAP_TAGGING_LEVEL: i32 = -204;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const LWIP_NO_STDDEF_H: u32 = 0;
pub const LWIP_NO_STDINT_H: u32 = 0;
pub const LWIP_HAVE_INT64: u32 = 1;
pub const LWIP_NO_INTTYPES_H: u32 = 0;
pub const __PRI_64_prefix: &[u8; 2usize] = b"l\0";
pub const __PRI_PTR_prefix: &[u8; 2usize] = b"l\0";
pub const __PRI_FAST_prefix: &[u8; 2usize] = b"l\0";
pub const PRId8: &[u8; 2usize] = b"d\0";
pub const PRId16: &[u8; 2usize] = b"d\0";
pub const PRId32: &[u8; 2usize] = b"d\0";
pub const PRId64: &[u8; 3usize] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST16: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST32: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST64: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST8: &[u8; 2usize] = b"d\0";
pub const PRIdFAST16: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST32: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST64: &[u8; 3usize] = b"ld\0";
pub const PRIdMAX: &[u8; 3usize] = b"jd\0";
pub const PRIdPTR: &[u8; 3usize] = b"ld\0";
pub const PRIi8: &[u8; 2usize] = b"i\0";
pub const PRIi16: &[u8; 2usize] = b"i\0";
pub const PRIi32: &[u8; 2usize] = b"i\0";
pub const PRIi64: &[u8; 3usize] = b"li\0";
pub const PRIiLEAST8: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST16: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST32: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST64: &[u8; 3usize] = b"li\0";
pub const PRIiFAST8: &[u8; 2usize] = b"i\0";
pub const PRIiFAST16: &[u8; 3usize] = b"li\0";
pub const PRIiFAST32: &[u8; 3usize] = b"li\0";
pub const PRIiFAST64: &[u8; 3usize] = b"li\0";
pub const PRIiMAX: &[u8; 3usize] = b"ji\0";
pub const PRIiPTR: &[u8; 3usize] = b"li\0";
pub const PRIo8: &[u8; 2usize] = b"o\0";
pub const PRIo16: &[u8; 2usize] = b"o\0";
pub const PRIo32: &[u8; 2usize] = b"o\0";
pub const PRIo64: &[u8; 3usize] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST16: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST32: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST64: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST8: &[u8; 2usize] = b"o\0";
pub const PRIoFAST16: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST32: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST64: &[u8; 3usize] = b"lo\0";
pub const PRIoMAX: &[u8; 3usize] = b"jo\0";
pub const PRIoPTR: &[u8; 3usize] = b"lo\0";
pub const PRIu8: &[u8; 2usize] = b"u\0";
pub const PRIu16: &[u8; 2usize] = b"u\0";
pub const PRIu32: &[u8; 2usize] = b"u\0";
pub const PRIu64: &[u8; 3usize] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST16: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST32: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST64: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST8: &[u8; 2usize] = b"u\0";
pub const PRIuFAST16: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST32: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST64: &[u8; 3usize] = b"lu\0";
pub const PRIuMAX: &[u8; 3usize] = b"ju\0";
pub const PRIuPTR: &[u8; 3usize] = b"lu\0";
pub const PRIx8: &[u8; 2usize] = b"x\0";
pub const PRIx16: &[u8; 2usize] = b"x\0";
pub const PRIx32: &[u8; 2usize] = b"x\0";
pub const PRIx64: &[u8; 3usize] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST16: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST32: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST64: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST8: &[u8; 2usize] = b"x\0";
pub const PRIxFAST16: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST32: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST64: &[u8; 3usize] = b"lx\0";
pub const PRIxMAX: &[u8; 3usize] = b"jx\0";
pub const PRIxPTR: &[u8; 3usize] = b"lx\0";
pub const PRIX8: &[u8; 2usize] = b"X\0";
pub const PRIX16: &[u8; 2usize] = b"X\0";
pub const PRIX32: &[u8; 2usize] = b"X\0";
pub const PRIX64: &[u8; 3usize] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST16: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST32: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST64: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST8: &[u8; 2usize] = b"X\0";
pub const PRIXFAST16: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST32: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST64: &[u8; 3usize] = b"lX\0";
pub const PRIXMAX: &[u8; 3usize] = b"jX\0";
pub const PRIXPTR: &[u8; 3usize] = b"lX\0";
pub const SCNd8: &[u8; 4usize] = b"hhd\0";
pub const SCNd16: &[u8; 3usize] = b"hd\0";
pub const SCNd32: &[u8; 2usize] = b"d\0";
pub const SCNd64: &[u8; 3usize] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3usize] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2usize] = b"d\0";
pub const SCNdLEAST64: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNdFAST16: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST32: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST64: &[u8; 3usize] = b"ld\0";
pub const SCNdMAX: &[u8; 3usize] = b"jd\0";
pub const SCNdPTR: &[u8; 3usize] = b"ld\0";
pub const SCNi8: &[u8; 4usize] = b"hhi\0";
pub const SCNi16: &[u8; 3usize] = b"hi\0";
pub const SCNi32: &[u8; 2usize] = b"i\0";
pub const SCNi64: &[u8; 3usize] = b"li\0";
pub const SCNiLEAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3usize] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2usize] = b"i\0";
pub const SCNiLEAST64: &[u8; 3usize] = b"li\0";
pub const SCNiFAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNiFAST16: &[u8; 3usize] = b"li\0";
pub const SCNiFAST32: &[u8; 3usize] = b"li\0";
pub const SCNiFAST64: &[u8; 3usize] = b"li\0";
pub const SCNiMAX: &[u8; 3usize] = b"ji\0";
pub const SCNiPTR: &[u8; 3usize] = b"li\0";
pub const SCNo8: &[u8; 4usize] = b"hho\0";
pub const SCNo16: &[u8; 3usize] = b"ho\0";
pub const SCNo32: &[u8; 2usize] = b"o\0";
pub const SCNo64: &[u8; 3usize] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4usize] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3usize] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2usize] = b"o\0";
pub const SCNoLEAST64: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST8: &[u8; 4usize] = b"hho\0";
pub const SCNoFAST16: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST32: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST64: &[u8; 3usize] = b"lo\0";
pub const SCNoMAX: &[u8; 3usize] = b"jo\0";
pub const SCNoPTR: &[u8; 3usize] = b"lo\0";
pub const SCNu8: &[u8; 4usize] = b"hhu\0";
pub const SCNu16: &[u8; 3usize] = b"hu\0";
pub const SCNu32: &[u8; 2usize] = b"u\0";
pub const SCNu64: &[u8; 3usize] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3usize] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2usize] = b"u\0";
pub const SCNuLEAST64: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNuFAST16: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST32: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST64: &[u8; 3usize] = b"lu\0";
pub const SCNuMAX: &[u8; 3usize] = b"ju\0";
pub const SCNuPTR: &[u8; 3usize] = b"lu\0";
pub const SCNx8: &[u8; 4usize] = b"hhx\0";
pub const SCNx16: &[u8; 3usize] = b"hx\0";
pub const SCNx32: &[u8; 2usize] = b"x\0";
pub const SCNx64: &[u8; 3usize] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3usize] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2usize] = b"x\0";
pub const SCNxLEAST64: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNxFAST16: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST32: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST64: &[u8; 3usize] = b"lx\0";
pub const SCNxMAX: &[u8; 3usize] = b"jx\0";
pub const SCNxPTR: &[u8; 3usize] = b"lx\0";
pub const X8_F: &[u8; 4usize] = b"02x\0";
pub const U16_F: &[u8; 2usize] = b"u\0";
pub const S16_F: &[u8; 2usize] = b"d\0";
pub const X16_F: &[u8; 2usize] = b"x\0";
pub const U32_F: &[u8; 2usize] = b"u\0";
pub const S32_F: &[u8; 2usize] = b"d\0";
pub const X32_F: &[u8; 2usize] = b"x\0";
pub const SZT_F: &[u8; 3usize] = b"lu\0";
pub const LWIP_NO_LIMITS_H: u32 = 0;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const PASS_MAX: u32 = 128;
pub const NL_ARGMAX: u32 = 9;
pub const NL_LANGMAX: u32 = 14;
pub const NL_MSGMAX: u32 = 32767;
pub const NL_NMAX: u32 = 1;
pub const NL_SETMAX: u32 = 255;
pub const NL_TEXTMAX: u32 = 255;
pub const CHAR_BIT: u32 = 8;
pub const LONG_BIT: u32 = 64;
pub const WORD_BIT: u32 = 32;
pub const SCHAR_MAX: u32 = 127;
pub const SCHAR_MIN: i32 = -128;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MIN: u32 = 0;
pub const CHAR_MAX: u32 = 255;
pub const USHRT_MAX: u32 = 65535;
pub const SHRT_MAX: u32 = 32767;
pub const SHRT_MIN: i32 = -32768;
pub const UINT_MAX: u32 = 4294967295;
pub const INT_MAX: u32 = 2147483647;
pub const INT_MIN: i32 = -2147483648;
pub const ULONG_MAX: i32 = -1;
pub const LONG_MAX: u64 = 9223372036854775807;
pub const LONG_MIN: i64 = -9223372036854775808;
pub const ULLONG_MAX: i32 = -1;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const LLONG_MIN: i64 = -9223372036854775808;
pub const LONG_LONG_MIN: i64 = -9223372036854775808;
pub const LONG_LONG_MAX: u64 = 9223372036854775807;
pub const ULONG_LONG_MAX: i32 = -1;
pub const UID_MAX: u32 = 4294967295;
pub const GID_MAX: u32 = 4294967295;
pub const SIZE_T_MAX: i32 = -1;
pub const SSIZE_MAX: u64 = 9223372036854775807;
pub const MB_LEN_MAX: u32 = 4;
pub const NZERO: u32 = 20;
pub const IOV_MAX: u32 = 1024;
pub const SEM_VALUE_MAX: u32 = 1073741823;
pub const _POSIX_VERSION: u32 = 200809;
pub const _POSIX2_VERSION: u32 = 200809;
pub const _XOPEN_VERSION: u32 = 700;
pub const __BIONIC_POSIX_FEATURE_MISSING: i32 = -1;
pub const _POSIX_ASYNCHRONOUS_IO: i32 = -1;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 1;
pub const _POSIX_CPUTIME: u32 = 200809;
pub const _POSIX_FSYNC: u32 = 200809;
pub const _POSIX_IPV6: u32 = 200809;
pub const _POSIX_MAPPED_FILES: u32 = 200809;
pub const _POSIX_MEMLOCK_RANGE: u32 = 200809;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200809;
pub const _POSIX_MESSAGE_PASSING: i32 = -1;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 200809;
pub const _POSIX_NO_TRUNC: u32 = 1;
pub const _POSIX_PRIORITIZED_IO: i32 = -1;
pub const _POSIX_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_RAW_SOCKETS: u32 = 200809;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200809;
pub const _POSIX_REGEXP: u32 = 1;
pub const _POSIX_SAVED_IDS: u32 = 1;
pub const _POSIX_SEMAPHORES: u32 = 200809;
pub const _POSIX_SHARED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_SHELL: u32 = 1;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_SYNCHRONIZED_IO: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200809;
pub const _POSIX_THREAD_CPUTIME: u32 = 200809;
pub const _POSIX_THREAD_PRIO_INHERIT: i32 = -1;
pub const _POSIX_THREAD_PRIO_PROTECT: i32 = -1;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_INHERIT: i32 = -1;
pub const _POSIX_THREAD_ROBUST_PRIO_PROTECT: i32 = -1;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200809;
pub const _POSIX_THREAD_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_THREADS: u32 = 200809;
pub const _POSIX_TIMERS: u32 = 200809;
pub const _POSIX_TRACE: i32 = -1;
pub const _POSIX_TRACE_EVENT_FILTER: i32 = -1;
pub const _POSIX_TRACE_INHERIT: i32 = -1;
pub const _POSIX_TRACE_LOG: i32 = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_VDISABLE: u8 = 0u8;
pub const _POSIX2_C_BIND: u32 = 200809;
pub const _POSIX2_C_DEV: i32 = -1;
pub const _POSIX2_CHAR_TERM: u32 = 200809;
pub const _POSIX2_FORT_DEV: i32 = -1;
pub const _POSIX2_FORT_RUN: i32 = -1;
pub const _POSIX2_LOCALEDEF: i32 = -1;
pub const _POSIX2_SW_DEV: i32 = -1;
pub const _POSIX2_UPE: i32 = -1;
pub const _POSIX_V7_ILP32_OFF32: i32 = -1;
pub const _POSIX_V7_ILP32_OFFBIG: i32 = -1;
pub const _POSIX_V7_LP64_OFF64: u32 = 1;
pub const _POSIX_V7_LPBIG_OFFBIG: u32 = 1;
pub const _XOPEN_CRYPT: i32 = -1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_LEGACY: i32 = -1;
pub const _XOPEN_REALTIME: u32 = 1;
pub const _XOPEN_REALTIME_THREADS: u32 = 1;
pub const _XOPEN_SHM: u32 = 1;
pub const _XOPEN_STREAMS: i32 = -1;
pub const _XOPEN_UNIX: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SS_REPL_MAX: u32 = 4;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TRACE_EVENT_NAME_MAX: u32 = 30;
pub const _POSIX_TRACE_NAME_MAX: u32 = 8;
pub const _POSIX_TRACE_SYS_MAX: u32 = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const _XOPEN_NAME_MAX: u32 = 255;
pub const _XOPEN_PATH_MAX: u32 = 1024;
pub const HOST_NAME_MAX: u32 = 255;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const TTY_NAME_MAX: u32 = 32;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_KEYS_MAX: u32 = 128;
pub const LWIP_NO_UNISTD_H: u32 = 0;
pub const ITIMER_REAL: u32 = 0;
pub const ITIMER_VIRTUAL: u32 = 1;
pub const ITIMER_PROF: u32 = 2;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_SGI_CYCLE: u32 = 10;
pub const CLOCK_TAI: u32 = 11;
pub const MAX_CLOCKS: u32 = 16;
pub const CLOCKS_MASK: u32 = 1;
pub const CLOCKS_MONO: u32 = 1;
pub const TIMER_ABSTIME: u32 = 1;
pub const FPSIMD_MAGIC: u32 = 1179680769;
pub const ESR_MAGIC: u32 = 1163088385;
pub const EXTRA_MAGIC: u32 = 1163416577;
pub const SVE_MAGIC: u32 = 1398162689;
pub const __SVE_VQ_BYTES: u32 = 16;
pub const __SVE_VQ_MIN: u32 = 1;
pub const __SVE_VQ_MAX: u32 = 512;
pub const __SVE_VL_MIN: u32 = 16;
pub const __SVE_VL_MAX: u32 = 8192;
pub const __SVE_NUM_ZREGS: u32 = 32;
pub const __SVE_NUM_PREGS: u32 = 16;
pub const __SVE_ZREGS_OFFSET: u32 = 0;
pub const SVE_VQ_BYTES: u32 = 16;
pub const SVE_VQ_MIN: u32 = 1;
pub const SVE_VQ_MAX: u32 = 512;
pub const SVE_VL_MIN: u32 = 16;
pub const SVE_VL_MAX: u32 = 8192;
pub const SVE_NUM_ZREGS: u32 = 32;
pub const SVE_NUM_PREGS: u32 = 16;
pub const SA_RESTORER: u32 = 67108864;
pub const MINSIGSTKSZ: u32 = 5120;
pub const SIGSTKSZ: u32 = 16384;
pub const _KERNEL__NSIG: u32 = 64;
pub const _NSIG_BPW: u32 = 64;
pub const _NSIG_WORDS: u32 = 1;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGBUS: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGUSR1: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGUSR2: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGSTKFLT: u32 = 16;
pub const SIGCHLD: u32 = 17;
pub const SIGCONT: u32 = 18;
pub const SIGSTOP: u32 = 19;
pub const SIGTSTP: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGURG: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGIO: u32 = 29;
pub const SIGPOLL: u32 = 29;
pub const SIGPWR: u32 = 30;
pub const SIGSYS: u32 = 31;
pub const SIGUNUSED: u32 = 31;
pub const __SIGRTMIN: u32 = 32;
pub const __SIGRTMAX: u32 = 64;
pub const SA_NOCLDSTOP: u32 = 1;
pub const SA_NOCLDWAIT: u32 = 2;
pub const SA_SIGINFO: u32 = 4;
pub const SA_UNSUPPORTED: u32 = 1024;
pub const SA_EXPOSE_TAGBITS: u32 = 2048;
pub const SA_ONSTACK: u32 = 134217728;
pub const SA_RESTART: u32 = 268435456;
pub const SA_NODEFER: u32 = 1073741824;
pub const SA_RESETHAND: u32 = 2147483648;
pub const SA_NOMASK: u32 = 1073741824;
pub const SA_ONESHOT: u32 = 2147483648;
pub const SIG_BLOCK: u32 = 0;
pub const SIG_UNBLOCK: u32 = 1;
pub const SIG_SETMASK: u32 = 2;
pub const SI_MAX_SIZE: u32 = 128;
pub const SI_USER: u32 = 0;
pub const SI_KERNEL: u32 = 128;
pub const SI_QUEUE: i32 = -1;
pub const SI_TIMER: i32 = -2;
pub const SI_MESGQ: i32 = -3;
pub const SI_ASYNCIO: i32 = -4;
pub const SI_SIGIO: i32 = -5;
pub const SI_TKILL: i32 = -6;
pub const SI_DETHREAD: i32 = -7;
pub const SI_ASYNCNL: i32 = -60;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLOPN: u32 = 2;
pub const ILL_ILLADR: u32 = 3;
pub const ILL_ILLTRP: u32 = 4;
pub const ILL_PRVOPC: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const ILL_BADIADDR: u32 = 9;
pub const __ILL_BREAK: u32 = 10;
pub const __ILL_BNDMOD: u32 = 11;
pub const NSIGILL: u32 = 11;
pub const FPE_INTDIV: u32 = 1;
pub const FPE_INTOVF: u32 = 2;
pub const FPE_FLTDIV: u32 = 3;
pub const FPE_FLTOVF: u32 = 4;
pub const FPE_FLTUND: u32 = 5;
pub const FPE_FLTRES: u32 = 6;
pub const FPE_FLTINV: u32 = 7;
pub const FPE_FLTSUB: u32 = 8;
pub const __FPE_DECOVF: u32 = 9;
pub const __FPE_DECDIV: u32 = 10;
pub const __FPE_DECERR: u32 = 11;
pub const __FPE_INVASC: u32 = 12;
pub const __FPE_INVDEC: u32 = 13;
pub const FPE_FLTUNK: u32 = 14;
pub const FPE_CONDTRAP: u32 = 15;
pub const NSIGFPE: u32 = 15;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const SEGV_BNDERR: u32 = 3;
pub const SEGV_PKUERR: u32 = 4;
pub const SEGV_ACCADI: u32 = 5;
pub const SEGV_ADIDERR: u32 = 6;
pub const SEGV_ADIPERR: u32 = 7;
pub const SEGV_MTEAERR: u32 = 8;
pub const SEGV_MTESERR: u32 = 9;
pub const NSIGSEGV: u32 = 9;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const BUS_MCEERR_AR: u32 = 4;
pub const BUS_MCEERR_AO: u32 = 5;
pub const NSIGBUS: u32 = 5;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const TRAP_BRANCH: u32 = 3;
pub const TRAP_HWBKPT: u32 = 4;
pub const TRAP_UNK: u32 = 5;
pub const TRAP_PERF: u32 = 6;
pub const NSIGTRAP: u32 = 6;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const NSIGCHLD: u32 = 6;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const NSIGPOLL: u32 = 6;
pub const SYS_SECCOMP: u32 = 1;
pub const SYS_USER_DISPATCH: u32 = 2;
pub const NSIGSYS: u32 = 2;
pub const EMT_TAGOVF: u32 = 1;
pub const NSIGEMT: u32 = 1;
pub const SIGEV_SIGNAL: u32 = 0;
pub const SIGEV_NONE: u32 = 1;
pub const SIGEV_THREAD: u32 = 2;
pub const SIGEV_THREAD_ID: u32 = 4;
pub const SIGEV_MAX_SIZE: u32 = 64;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 2;
pub const SS_AUTODISARM: u32 = 2147483648;
pub const SS_FLAG_BITS: u32 = 2147483648;
pub const _NSIG: u32 = 65;
pub const NSIG: u32 = 65;
pub const PAGE_SIZE: u32 = 4096;
pub const PAGE_MASK: i32 = -4096;
pub const NGREG: u32 = 34;
pub const FD_SETSIZE: u32 = 1024;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const _SC_ARG_MAX: u32 = 0;
pub const _SC_BC_BASE_MAX: u32 = 1;
pub const _SC_BC_DIM_MAX: u32 = 2;
pub const _SC_BC_SCALE_MAX: u32 = 3;
pub const _SC_BC_STRING_MAX: u32 = 4;
pub const _SC_CHILD_MAX: u32 = 5;
pub const _SC_CLK_TCK: u32 = 6;
pub const _SC_COLL_WEIGHTS_MAX: u32 = 7;
pub const _SC_EXPR_NEST_MAX: u32 = 8;
pub const _SC_LINE_MAX: u32 = 9;
pub const _SC_NGROUPS_MAX: u32 = 10;
pub const _SC_OPEN_MAX: u32 = 11;
pub const _SC_PASS_MAX: u32 = 12;
pub const _SC_2_C_BIND: u32 = 13;
pub const _SC_2_C_DEV: u32 = 14;
pub const _SC_2_C_VERSION: u32 = 15;
pub const _SC_2_CHAR_TERM: u32 = 16;
pub const _SC_2_FORT_DEV: u32 = 17;
pub const _SC_2_FORT_RUN: u32 = 18;
pub const _SC_2_LOCALEDEF: u32 = 19;
pub const _SC_2_SW_DEV: u32 = 20;
pub const _SC_2_UPE: u32 = 21;
pub const _SC_2_VERSION: u32 = 22;
pub const _SC_JOB_CONTROL: u32 = 23;
pub const _SC_SAVED_IDS: u32 = 24;
pub const _SC_VERSION: u32 = 25;
pub const _SC_RE_DUP_MAX: u32 = 26;
pub const _SC_STREAM_MAX: u32 = 27;
pub const _SC_TZNAME_MAX: u32 = 28;
pub const _SC_XOPEN_CRYPT: u32 = 29;
pub const _SC_XOPEN_ENH_I18N: u32 = 30;
pub const _SC_XOPEN_SHM: u32 = 31;
pub const _SC_XOPEN_VERSION: u32 = 32;
pub const _SC_XOPEN_XCU_VERSION: u32 = 33;
pub const _SC_XOPEN_REALTIME: u32 = 34;
pub const _SC_XOPEN_REALTIME_THREADS: u32 = 35;
pub const _SC_XOPEN_LEGACY: u32 = 36;
pub const _SC_ATEXIT_MAX: u32 = 37;
pub const _SC_IOV_MAX: u32 = 38;
pub const _SC_UIO_MAXIOV: u32 = 38;
pub const _SC_PAGESIZE: u32 = 39;
pub const _SC_PAGE_SIZE: u32 = 40;
pub const _SC_XOPEN_UNIX: u32 = 41;
pub const _SC_XBS5_ILP32_OFF32: u32 = 42;
pub const _SC_XBS5_ILP32_OFFBIG: u32 = 43;
pub const _SC_XBS5_LP64_OFF64: u32 = 44;
pub const _SC_XBS5_LPBIG_OFFBIG: u32 = 45;
pub const _SC_AIO_LISTIO_MAX: u32 = 46;
pub const _SC_AIO_MAX: u32 = 47;
pub const _SC_AIO_PRIO_DELTA_MAX: u32 = 48;
pub const _SC_DELAYTIMER_MAX: u32 = 49;
pub const _SC_MQ_OPEN_MAX: u32 = 50;
pub const _SC_MQ_PRIO_MAX: u32 = 51;
pub const _SC_RTSIG_MAX: u32 = 52;
pub const _SC_SEM_NSEMS_MAX: u32 = 53;
pub const _SC_SEM_VALUE_MAX: u32 = 54;
pub const _SC_SIGQUEUE_MAX: u32 = 55;
pub const _SC_TIMER_MAX: u32 = 56;
pub const _SC_ASYNCHRONOUS_IO: u32 = 57;
pub const _SC_FSYNC: u32 = 58;
pub const _SC_MAPPED_FILES: u32 = 59;
pub const _SC_MEMLOCK: u32 = 60;
pub const _SC_MEMLOCK_RANGE: u32 = 61;
pub const _SC_MEMORY_PROTECTION: u32 = 62;
pub const _SC_MESSAGE_PASSING: u32 = 63;
pub const _SC_PRIORITIZED_IO: u32 = 64;
pub const _SC_PRIORITY_SCHEDULING: u32 = 65;
pub const _SC_REALTIME_SIGNALS: u32 = 66;
pub const _SC_SEMAPHORES: u32 = 67;
pub const _SC_SHARED_MEMORY_OBJECTS: u32 = 68;
pub const _SC_SYNCHRONIZED_IO: u32 = 69;
pub const _SC_TIMERS: u32 = 70;
pub const _SC_GETGR_R_SIZE_MAX: u32 = 71;
pub const _SC_GETPW_R_SIZE_MAX: u32 = 72;
pub const _SC_LOGIN_NAME_MAX: u32 = 73;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: u32 = 74;
pub const _SC_THREAD_KEYS_MAX: u32 = 75;
pub const _SC_THREAD_STACK_MIN: u32 = 76;
pub const _SC_THREAD_THREADS_MAX: u32 = 77;
pub const _SC_TTY_NAME_MAX: u32 = 78;
pub const _SC_THREADS: u32 = 79;
pub const _SC_THREAD_ATTR_STACKADDR: u32 = 80;
pub const _SC_THREAD_ATTR_STACKSIZE: u32 = 81;
pub const _SC_THREAD_PRIORITY_SCHEDULING: u32 = 82;
pub const _SC_THREAD_PRIO_INHERIT: u32 = 83;
pub const _SC_THREAD_PRIO_PROTECT: u32 = 84;
pub const _SC_THREAD_SAFE_FUNCTIONS: u32 = 85;
pub const _SC_NPROCESSORS_CONF: u32 = 96;
pub const _SC_NPROCESSORS_ONLN: u32 = 97;
pub const _SC_PHYS_PAGES: u32 = 98;
pub const _SC_AVPHYS_PAGES: u32 = 99;
pub const _SC_MONOTONIC_CLOCK: u32 = 100;
pub const _SC_2_PBS: u32 = 101;
pub const _SC_2_PBS_ACCOUNTING: u32 = 102;
pub const _SC_2_PBS_CHECKPOINT: u32 = 103;
pub const _SC_2_PBS_LOCATE: u32 = 104;
pub const _SC_2_PBS_MESSAGE: u32 = 105;
pub const _SC_2_PBS_TRACK: u32 = 106;
pub const _SC_ADVISORY_INFO: u32 = 107;
pub const _SC_BARRIERS: u32 = 108;
pub const _SC_CLOCK_SELECTION: u32 = 109;
pub const _SC_CPUTIME: u32 = 110;
pub const _SC_HOST_NAME_MAX: u32 = 111;
pub const _SC_IPV6: u32 = 112;
pub const _SC_RAW_SOCKETS: u32 = 113;
pub const _SC_READER_WRITER_LOCKS: u32 = 114;
pub const _SC_REGEXP: u32 = 115;
pub const _SC_SHELL: u32 = 116;
pub const _SC_SPAWN: u32 = 117;
pub const _SC_SPIN_LOCKS: u32 = 118;
pub const _SC_SPORADIC_SERVER: u32 = 119;
pub const _SC_SS_REPL_MAX: u32 = 120;
pub const _SC_SYMLOOP_MAX: u32 = 121;
pub const _SC_THREAD_CPUTIME: u32 = 122;
pub const _SC_THREAD_PROCESS_SHARED: u32 = 123;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: u32 = 124;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: u32 = 125;
pub const _SC_THREAD_SPORADIC_SERVER: u32 = 126;
pub const _SC_TIMEOUTS: u32 = 127;
pub const _SC_TRACE: u32 = 128;
pub const _SC_TRACE_EVENT_FILTER: u32 = 129;
pub const _SC_TRACE_EVENT_NAME_MAX: u32 = 130;
pub const _SC_TRACE_INHERIT: u32 = 131;
pub const _SC_TRACE_LOG: u32 = 132;
pub const _SC_TRACE_NAME_MAX: u32 = 133;
pub const _SC_TRACE_SYS_MAX: u32 = 134;
pub const _SC_TRACE_USER_EVENT_MAX: u32 = 135;
pub const _SC_TYPED_MEMORY_OBJECTS: u32 = 136;
pub const _SC_V7_ILP32_OFF32: u32 = 137;
pub const _SC_V7_ILP32_OFFBIG: u32 = 138;
pub const _SC_V7_LP64_OFF64: u32 = 139;
pub const _SC_V7_LPBIG_OFFBIG: u32 = 140;
pub const _SC_XOPEN_STREAMS: u32 = 141;
pub const _SC_XOPEN_UUCP: u32 = 142;
pub const _SC_LEVEL1_ICACHE_SIZE: u32 = 143;
pub const _SC_LEVEL1_ICACHE_ASSOC: u32 = 144;
pub const _SC_LEVEL1_ICACHE_LINESIZE: u32 = 145;
pub const _SC_LEVEL1_DCACHE_SIZE: u32 = 146;
pub const _SC_LEVEL1_DCACHE_ASSOC: u32 = 147;
pub const _SC_LEVEL1_DCACHE_LINESIZE: u32 = 148;
pub const _SC_LEVEL2_CACHE_SIZE: u32 = 149;
pub const _SC_LEVEL2_CACHE_ASSOC: u32 = 150;
pub const _SC_LEVEL2_CACHE_LINESIZE: u32 = 151;
pub const _SC_LEVEL3_CACHE_SIZE: u32 = 152;
pub const _SC_LEVEL3_CACHE_ASSOC: u32 = 153;
pub const _SC_LEVEL3_CACHE_LINESIZE: u32 = 154;
pub const _SC_LEVEL4_CACHE_SIZE: u32 = 155;
pub const _SC_LEVEL4_CACHE_ASSOC: u32 = 156;
pub const _SC_LEVEL4_CACHE_LINESIZE: u32 = 157;
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const F_OK: u32 = 0;
pub const X_OK: u32 = 1;
pub const W_OK: u32 = 2;
pub const R_OK: u32 = 4;
pub const _PC_FILESIZEBITS: u32 = 0;
pub const _PC_LINK_MAX: u32 = 1;
pub const _PC_MAX_CANON: u32 = 2;
pub const _PC_MAX_INPUT: u32 = 3;
pub const _PC_NAME_MAX: u32 = 4;
pub const _PC_PATH_MAX: u32 = 5;
pub const _PC_PIPE_BUF: u32 = 6;
pub const _PC_2_SYMLINKS: u32 = 7;
pub const _PC_ALLOC_SIZE_MIN: u32 = 8;
pub const _PC_REC_INCR_XFER_SIZE: u32 = 9;
pub const _PC_REC_MAX_XFER_SIZE: u32 = 10;
pub const _PC_REC_MIN_XFER_SIZE: u32 = 11;
pub const _PC_REC_XFER_ALIGN: u32 = 12;
pub const _PC_SYMLINK_MAX: u32 = 13;
pub const _PC_CHOWN_RESTRICTED: u32 = 14;
pub const _PC_NO_TRUNC: u32 = 15;
pub const _PC_VDISABLE: u32 = 16;
pub const _PC_ASYNC_IO: u32 = 17;
pub const _PC_PRIO_IO: u32 = 18;
pub const _PC_SYNC_IO: u32 = 19;
pub const LWIP_UINT32_MAX: u32 = 4294967295;
pub const LWIP_NO_CTYPE_H: u32 = 0;
pub const _CTYPE_U: u32 = 1;
pub const _CTYPE_L: u32 = 2;
pub const _CTYPE_D: u32 = 4;
pub const _CTYPE_S: u32 = 8;
pub const _CTYPE_P: u32 = 16;
pub const _CTYPE_C: u32 = 32;
pub const _CTYPE_X: u32 = 64;
pub const _CTYPE_B: u32 = 128;
pub const _CTYPE_R: u32 = 151;
pub const _CTYPE_A: u32 = 3;
pub const _CTYPE_N: u32 = 4;
pub const LWIP_DBG_LEVEL_ALL: u32 = 0;
pub const LWIP_DBG_LEVEL_WARNING: u32 = 1;
pub const LWIP_DBG_LEVEL_SERIOUS: u32 = 2;
pub const LWIP_DBG_LEVEL_SEVERE: u32 = 3;
pub const LWIP_DBG_MASK_LEVEL: u32 = 3;
pub const LWIP_DBG_LEVEL_OFF: u32 = 0;
pub const LWIP_DBG_ON: u32 = 128;
pub const LWIP_DBG_OFF: u32 = 0;
pub const LWIP_DBG_TRACE: u32 = 64;
pub const LWIP_DBG_STATE: u32 = 32;
pub const LWIP_DBG_FRESH: u32 = 16;
pub const LWIP_DBG_HALT: u32 = 8;
pub const LWIP_TIMERS_CUSTOM: u32 = 0;
pub const LWIP_MPU_COMPATIBLE: u32 = 0;
pub const LWIP_TCPIP_CORE_LOCKING: u32 = 1;
pub const LWIP_TCPIP_CORE_LOCKING_INPUT: u32 = 0;
pub const MEMP_MEM_INIT: u32 = 0;
pub const MEM_SIZE: u32 = 1600;
pub const MEMP_OVERFLOW_CHECK: u32 = 0;
pub const MEMP_SANITY_CHECK: u32 = 0;
pub const MEM_OVERFLOW_CHECK: u32 = 0;
pub const MEM_SANITY_CHECK: u32 = 0;
pub const MEM_USE_POOLS: u32 = 0;
pub const MEM_USE_POOLS_TRY_BIGGER_POOL: u32 = 0;
pub const MEMP_USE_CUSTOM_POOLS: u32 = 0;
pub const LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT: u32 = 0;
pub const MEMP_NUM_PBUF: u32 = 16;
pub const MEMP_NUM_RAW_PCB: u32 = 4;
pub const MEMP_NUM_UDP_PCB: u32 = 4;
pub const MEMP_NUM_TCP_SEG: u32 = 16;
pub const MEMP_NUM_ALTCP_PCB: u32 = 1024;
pub const MEMP_NUM_REASSDATA: u32 = 5;
pub const MEMP_NUM_FRAG_PBUF: u32 = 15;
pub const MEMP_NUM_ARP_QUEUE: u32 = 30;
pub const MEMP_NUM_IGMP_GROUP: u32 = 8;
pub const MEMP_NUM_NETBUF: u32 = 2;
pub const MEMP_NUM_NETCONN: u32 = 4;
pub const MEMP_NUM_SELECT_CB: u32 = 4;
pub const MEMP_NUM_TCPIP_MSG_API: u32 = 8;
pub const MEMP_NUM_TCPIP_MSG_INPKT: u32 = 8;
pub const MEMP_NUM_NETDB: u32 = 1;
pub const MEMP_NUM_LOCALHOSTLIST: u32 = 1;
pub const PBUF_POOL_SIZE: u32 = 16;
pub const MEMP_NUM_API_MSG: u32 = 8;
pub const MEMP_NUM_DNS_API_MSG: u32 = 8;
pub const MEMP_NUM_SOCKET_SETGETSOCKOPT_DATA: u32 = 8;
pub const MEMP_NUM_NETIFAPI_MSG: u32 = 8;
pub const ARP_TABLE_SIZE: u32 = 10;
pub const ARP_MAXAGE: u32 = 300;
pub const ARP_QUEUE_LEN: u32 = 3;
pub const ETHARP_SUPPORT_VLAN: u32 = 0;
pub const LWIP_ETHERNET: u32 = 0;
pub const ETH_PAD_SIZE: u32 = 0;
pub const ETHARP_SUPPORT_STATIC_ENTRIES: u32 = 0;
pub const LWIP_IPV4: u32 = 1;
pub const IP_REASSEMBLY: u32 = 1;
pub const IP_FRAG: u32 = 1;
pub const IP_OPTIONS_ALLOWED: u32 = 1;
pub const IP_REASS_MAXAGE: u32 = 15;
pub const IP_REASS_MAX_PBUFS: u32 = 10;
pub const IP_DEFAULT_TTL: u32 = 255;
pub const IP_SOF_BROADCAST: u32 = 0;
pub const IP_SOF_BROADCAST_RECV: u32 = 0;
pub const IP_FORWARD_ALLOW_TX_ON_RX_NETIF: u32 = 0;
pub const ICMP_TTL: u32 = 255;
pub const LWIP_BROADCAST_PING: u32 = 0;
pub const LWIP_MULTICAST_PING: u32 = 0;
pub const RAW_TTL: u32 = 255;
pub const LWIP_DHCP_BOOTP_FILE: u32 = 0;
pub const LWIP_DHCP_GET_NTP_SRV: u32 = 0;
pub const LWIP_DHCP_MAX_NTP_SERVERS: u32 = 1;
pub const LWIP_DHCP_AUTOIP_COOP: u32 = 0;
pub const LWIP_DHCP_AUTOIP_COOP_TRIES: u32 = 9;
pub const LWIP_MIB2_CALLBACKS: u32 = 0;
pub const DNS_TABLE_SIZE: u32 = 4;
pub const DNS_MAX_NAME_LENGTH: u32 = 256;
pub const DNS_MAX_SERVERS: u32 = 2;
pub const DNS_MAX_RETRIES: u32 = 4;
pub const DNS_DOES_NAME_CHECK: u32 = 1;
pub const LWIP_DNS_SECURE_RAND_XID: u32 = 1;
pub const LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING: u32 = 2;
pub const LWIP_DNS_SECURE_RAND_SRC_PORT: u32 = 4;
pub const DNS_LOCAL_HOSTLIST: u32 = 0;
pub const DNS_LOCAL_HOSTLIST_IS_DYNAMIC: u32 = 0;
pub const LWIP_DNS_SUPPORT_MDNS_QUERIES: u32 = 0;
pub const UDP_TTL: u32 = 255;
pub const LWIP_NETBUF_RECVINFO: u32 = 0;
pub const TCP_TTL: u32 = 255;
pub const TCP_WND: u32 = 5840;
pub const TCP_MAXRTX: u32 = 12;
pub const TCP_SYNMAXRTX: u32 = 6;
pub const TCP_QUEUE_OOSEQ: u32 = 1;
pub const LWIP_TCP_SACK_OUT: u32 = 0;
pub const LWIP_TCP_MAX_SACK_NUM: u32 = 4;
pub const TCP_CALCULATE_EFF_SEND_MSS: u32 = 1;
pub const TCP_OOSEQ_MAX_BYTES: u32 = 0;
pub const TCP_OOSEQ_MAX_PBUFS: u32 = 0;
pub const TCP_LISTEN_BACKLOG: u32 = 0;
pub const TCP_DEFAULT_LISTEN_BACKLOG: u32 = 255;
pub const TCP_OVERSIZE: u32 = 1460;
pub const LWIP_TCP_TIMESTAMPS: u32 = 0;
pub const LWIP_EVENT_API: u32 = 0;
pub const LWIP_WND_SCALE: u32 = 0;
pub const TCP_RCV_SCALE: u32 = 0;
pub const LWIP_TCP_PCB_NUM_EXT_ARGS: u32 = 0;
pub const LWIP_ALTCP: u32 = 0;
pub const LWIP_ALTCP_TLS: u32 = 0;
pub const PBUF_LINK_HLEN: u32 = 14;
pub const PBUF_LINK_ENCAPSULATION_HLEN: u32 = 0;
pub const LWIP_SINGLE_NETIF: u32 = 0;
pub const LWIP_NETIF_HOSTNAME: u32 = 0;
pub const LWIP_NETIF_STATUS_CALLBACK: u32 = 0;
pub const LWIP_NETIF_EXT_STATUS_CALLBACK: u32 = 0;
pub const LWIP_NETIF_LINK_CALLBACK: u32 = 0;
pub const LWIP_NETIF_REMOVE_CALLBACK: u32 = 0;
pub const LWIP_NETIF_HWADDRHINT: u32 = 0;
pub const LWIP_NETIF_TX_SINGLE_PBUF: u32 = 0;
pub const LWIP_NUM_NETIF_CLIENT_DATA: u32 = 0;
pub const LWIP_LOOPIF_MULTICAST: u32 = 0;
pub const LWIP_LOOPBACK_MAX_PBUFS: u32 = 0;
pub const TCPIP_THREAD_NAME: &[u8; 13usize] = b"tcpip_thread\0";
pub const TCPIP_THREAD_STACKSIZE: u32 = 0;
pub const TCPIP_THREAD_PRIO: u32 = 1;
pub const TCPIP_MBOX_SIZE: u32 = 0;
pub const SLIPIF_THREAD_NAME: &[u8; 12usize] = b"slipif_loop\0";
pub const SLIPIF_THREAD_STACKSIZE: u32 = 0;
pub const SLIPIF_THREAD_PRIO: u32 = 1;
pub const DEFAULT_THREAD_NAME: &[u8; 5usize] = b"lwIP\0";
pub const DEFAULT_THREAD_STACKSIZE: u32 = 0;
pub const DEFAULT_THREAD_PRIO: u32 = 1;
pub const DEFAULT_RAW_RECVMBOX_SIZE: u32 = 0;
pub const DEFAULT_UDP_RECVMBOX_SIZE: u32 = 0;
pub const DEFAULT_TCP_RECVMBOX_SIZE: u32 = 0;
pub const DEFAULT_ACCEPTMBOX_SIZE: u32 = 0;
pub const LWIP_TCPIP_TIMEOUT: u32 = 0;
pub const LWIP_NETCONN_SEM_PER_THREAD: u32 = 0;
pub const LWIP_NETCONN_FULLDUPLEX: u32 = 0;
pub const LWIP_COMPAT_SOCKETS: u32 = 1;
pub const LWIP_POSIX_SOCKETS_IO_NAMES: u32 = 1;
pub const LWIP_SOCKET_OFFSET: u32 = 0;
pub const LWIP_TCP_KEEPALIVE: u32 = 0;
pub const LWIP_SO_SNDTIMEO: u32 = 0;
pub const LWIP_SO_RCVTIMEO: u32 = 0;
pub const LWIP_SO_SNDRCVTIMEO_NONSTANDARD: u32 = 0;
pub const LWIP_SO_RCVBUF: u32 = 0;
pub const LWIP_SO_LINGER: u32 = 0;
pub const RECV_BUFSIZE_DEFAULT: u32 = 2147483647;
pub const LWIP_TCP_CLOSE_TIMEOUT_MS_DEFAULT: u32 = 20000;
pub const SO_REUSE: u32 = 0;
pub const SO_REUSE_RXTOALL: u32 = 0;
pub const LWIP_FIONREAD_LINUXMODE: u32 = 0;
pub const LWIP_SOCKET_SELECT: u32 = 1;
pub const LWIP_SOCKET_POLL: u32 = 1;
pub const LWIP_STATS: u32 = 1;
pub const LWIP_STATS_DISPLAY: u32 = 0;
pub const LINK_STATS: u32 = 1;
pub const ETHARP_STATS: u32 = 0;
pub const IP_STATS: u32 = 1;
pub const ICMP_STATS: u32 = 1;
pub const IGMP_STATS: u32 = 0;
pub const UDP_STATS: u32 = 0;
pub const TCP_STATS: u32 = 1;
pub const IP6_STATS: u32 = 1;
pub const ND6_STATS: u32 = 1;
pub const MIB2_STATS: u32 = 0;
pub const LWIP_CHECKSUM_CTRL_PER_NETIF: u32 = 0;
pub const CHECKSUM_GEN_IP: u32 = 1;
pub const CHECKSUM_GEN_UDP: u32 = 1;
pub const CHECKSUM_GEN_TCP: u32 = 1;
pub const CHECKSUM_GEN_ICMP: u32 = 1;
pub const CHECKSUM_GEN_ICMP6: u32 = 1;
pub const CHECKSUM_CHECK_IP: u32 = 1;
pub const CHECKSUM_CHECK_UDP: u32 = 1;
pub const CHECKSUM_CHECK_TCP: u32 = 1;
pub const CHECKSUM_CHECK_ICMP: u32 = 1;
pub const CHECKSUM_CHECK_ICMP6: u32 = 1;
pub const LWIP_CHECKSUM_ON_COPY: u32 = 0;
pub const IPV6_REASS_MAXAGE: u32 = 60;
pub const LWIP_IPV6_SCOPES_DEBUG: u32 = 0;
pub const LWIP_IPV6_NUM_ADDRESSES: u32 = 3;
pub const LWIP_IPV6_FORWARD: u32 = 0;
pub const LWIP_IPV6_FRAG: u32 = 1;
pub const LWIP_IPV6_REASS: u32 = 1;
pub const LWIP_IPV6_SEND_ROUTER_SOLICIT: u32 = 1;
pub const LWIP_IPV6_ADDRESS_LIFETIMES: u32 = 0;
pub const LWIP_IPV6_DUP_DETECT_ATTEMPTS: u32 = 1;
pub const LWIP_ICMP6: u32 = 1;
pub const LWIP_ICMP6_DATASIZE: u32 = 0;
pub const LWIP_ICMP6_HL: u32 = 255;
pub const MEMP_NUM_MLD6_GROUP: u32 = 4;
pub const LWIP_ND6_QUEUEING: u32 = 1;
pub const MEMP_NUM_ND6_QUEUE: u32 = 20;
pub const LWIP_ND6_NUM_NEIGHBORS: u32 = 10;
pub const LWIP_ND6_NUM_DESTINATIONS: u32 = 10;
pub const LWIP_ND6_NUM_PREFIXES: u32 = 5;
pub const LWIP_ND6_NUM_ROUTERS: u32 = 3;
pub const LWIP_ND6_MAX_MULTICAST_SOLICIT: u32 = 3;
pub const LWIP_ND6_MAX_UNICAST_SOLICIT: u32 = 3;
pub const LWIP_ND6_MAX_ANYCAST_DELAY_TIME: u32 = 1000;
pub const LWIP_ND6_MAX_NEIGHBOR_ADVERTISEMENT: u32 = 3;
pub const LWIP_ND6_REACHABLE_TIME: u32 = 30000;
pub const LWIP_ND6_RETRANS_TIMER: u32 = 1000;
pub const LWIP_ND6_DELAY_FIRST_PROBE_TIME: u32 = 5000;
pub const LWIP_ND6_ALLOW_RA_UPDATES: u32 = 1;
pub const LWIP_ND6_TCP_REACHABILITY_HINTS: u32 = 1;
pub const LWIP_ND6_RDNSS_MAX_DNS_SERVERS: u32 = 0;
pub const LWIP_IPV6_DHCP6: u32 = 0;
pub const LWIP_IPV6_DHCP6_STATEFUL: u32 = 0;
pub const LWIP_IPV6_DHCP6_STATELESS: u32 = 0;
pub const LWIP_DHCP6_GET_NTP_SRV: u32 = 0;
pub const LWIP_DHCP6_MAX_NTP_SERVERS: u32 = 1;
pub const LWIP_DHCP6_MAX_DNS_SERVERS: u32 = 2;
pub const LWIP_DBG_MIN_LEVEL: u32 = 0;
pub const LWIP_DBG_TYPES_ON: u32 = 128;
pub const ETHARP_DEBUG: u32 = 0;
pub const NETIF_DEBUG: u32 = 0;
pub const PBUF_DEBUG: u32 = 0;
pub const API_LIB_DEBUG: u32 = 0;
pub const API_MSG_DEBUG: u32 = 0;
pub const SOCKETS_DEBUG: u32 = 0;
pub const ICMP_DEBUG: u32 = 0;
pub const IGMP_DEBUG: u32 = 0;
pub const INET_DEBUG: u32 = 0;
pub const IP_DEBUG: u32 = 0;
pub const IP_REASS_DEBUG: u32 = 0;
pub const RAW_DEBUG: u32 = 0;
pub const MEM_DEBUG: u32 = 0;
pub const MEMP_DEBUG: u32 = 0;
pub const SYS_DEBUG: u32 = 0;
pub const TIMERS_DEBUG: u32 = 0;
pub const TCP_DEBUG: u32 = 0;
pub const TCP_INPUT_DEBUG: u32 = 0;
pub const TCP_FR_DEBUG: u32 = 0;
pub const TCP_RTO_DEBUG: u32 = 0;
pub const TCP_CWND_DEBUG: u32 = 0;
pub const TCP_WND_DEBUG: u32 = 0;
pub const TCP_OUTPUT_DEBUG: u32 = 0;
pub const TCP_RST_DEBUG: u32 = 0;
pub const TCP_QLEN_DEBUG: u32 = 0;
pub const UDP_DEBUG: u32 = 0;
pub const TCPIP_DEBUG: u32 = 0;
pub const SLIP_DEBUG: u32 = 0;
pub const DHCP_DEBUG: u32 = 0;
pub const AUTOIP_DEBUG: u32 = 0;
pub const DNS_DEBUG: u32 = 0;
pub const IP6_DEBUG: u32 = 0;
pub const DHCP6_DEBUG: u32 = 0;
pub const LWIP_TESTMODE: u32 = 0;
pub const LWIP_VERSION_MAJOR: u32 = 2;
pub const LWIP_VERSION_MINOR: u32 = 1;
pub const LWIP_VERSION_REVISION: u32 = 4;
pub const LWIP_RC_RELEASE: u32 = 255;
pub const LWIP_RC_DEVELOPMENT: u32 = 0;
pub const LWIP_VERSION_STRING_SUFFIX: &[u8; 2usize] = b"d\0";
pub const TCP_WRITE_FLAG_COPY: u32 = 1;
pub const TCP_WRITE_FLAG_MORE: u32 = 2;
pub const TCP_PRIO_MIN: u32 = 1;
pub const TCP_PRIO_NORMAL: u32 = 64;
pub const TCP_PRIO_MAX: u32 = 127;
pub const MEM_SIZE_F: &[u8; 3usize] = b"lu\0";
pub const PBUF_TRANSPORT_HLEN: u32 = 20;
pub const PBUF_IP_HLEN: u32 = 40;
pub const PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS: u32 = 128;
pub const PBUF_TYPE_FLAG_DATA_VOLATILE: u32 = 64;
pub const PBUF_TYPE_ALLOC_SRC_MASK: u32 = 15;
pub const PBUF_ALLOC_FLAG_RX: u32 = 256;
pub const PBUF_ALLOC_FLAG_DATA_CONTIGUOUS: u32 = 512;
pub const PBUF_TYPE_ALLOC_SRC_MASK_STD_HEAP: u32 = 0;
pub const PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF: u32 = 1;
pub const PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF_POOL: u32 = 2;
pub const PBUF_TYPE_ALLOC_SRC_MASK_APP_MIN: u32 = 3;
pub const PBUF_TYPE_ALLOC_SRC_MASK_APP_MAX: u32 = 15;
pub const PBUF_FLAG_PUSH: u32 = 1;
pub const PBUF_FLAG_IS_CUSTOM: u32 = 2;
pub const PBUF_FLAG_MCASTLOOP: u32 = 4;
pub const PBUF_FLAG_LLBCAST: u32 = 8;
pub const PBUF_FLAG_LLMCAST: u32 = 16;
pub const PBUF_FLAG_TCP_FIN: u32 = 32;
pub const PBUF_POOL_FREE_OOSEQ: u32 = 1;
pub const IP_CLASSA_NET: u32 = 4278190080;
pub const IP_CLASSA_NSHIFT: u32 = 24;
pub const IP_CLASSA_HOST: u32 = 16777215;
pub const IP_CLASSA_MAX: u32 = 128;
pub const IP_CLASSB_NET: u32 = 4294901760;
pub const IP_CLASSB_NSHIFT: u32 = 16;
pub const IP_CLASSB_HOST: u32 = 65535;
pub const IP_CLASSB_MAX: u32 = 65536;
pub const IP_CLASSC_NET: u32 = 4294967040;
pub const IP_CLASSC_NSHIFT: u32 = 8;
pub const IP_CLASSC_HOST: u32 = 255;
pub const IP_CLASSD_NET: u32 = 4026531840;
pub const IP_CLASSD_NSHIFT: u32 = 28;
pub const IP_CLASSD_HOST: u32 = 268435455;
pub const IP_LOOPBACKNET: u32 = 127;
pub const IP4ADDR_STRLEN_MAX: u32 = 16;
pub const IP6_NO_ZONE: u32 = 0;
pub const IPV6_CUSTOM_SCOPES: u32 = 0;
pub const IP6_MULTICAST_SCOPE_RESERVED: u32 = 0;
pub const IP6_MULTICAST_SCOPE_RESERVED0: u32 = 0;
pub const IP6_MULTICAST_SCOPE_INTERFACE_LOCAL: u32 = 1;
pub const IP6_MULTICAST_SCOPE_LINK_LOCAL: u32 = 2;
pub const IP6_MULTICAST_SCOPE_RESERVED3: u32 = 3;
pub const IP6_MULTICAST_SCOPE_ADMIN_LOCAL: u32 = 4;
pub const IP6_MULTICAST_SCOPE_SITE_LOCAL: u32 = 5;
pub const IP6_MULTICAST_SCOPE_ORGANIZATION_LOCAL: u32 = 8;
pub const IP6_MULTICAST_SCOPE_GLOBAL: u32 = 14;
pub const IP6_MULTICAST_SCOPE_RESERVEDF: u32 = 15;
pub const IP6_ADDR_INVALID: u32 = 0;
pub const IP6_ADDR_TENTATIVE: u32 = 8;
pub const IP6_ADDR_TENTATIVE_1: u32 = 9;
pub const IP6_ADDR_TENTATIVE_2: u32 = 10;
pub const IP6_ADDR_TENTATIVE_3: u32 = 11;
pub const IP6_ADDR_TENTATIVE_4: u32 = 12;
pub const IP6_ADDR_TENTATIVE_5: u32 = 13;
pub const IP6_ADDR_TENTATIVE_6: u32 = 14;
pub const IP6_ADDR_TENTATIVE_7: u32 = 15;
pub const IP6_ADDR_VALID: u32 = 16;
pub const IP6_ADDR_PREFERRED: u32 = 48;
pub const IP6_ADDR_DEPRECATED: u32 = 16;
pub const IP6_ADDR_DUPLICATED: u32 = 64;
pub const IP6_ADDR_TENTATIVE_COUNT_MASK: u32 = 7;
pub const IP6ADDR_STRLEN_MAX: u32 = 46;
pub const IPADDR_STRLEN_MAX: u32 = 46;
pub const MEMP_SIZE: u32 = 0;
pub const LWIP_STATS_LARGE: u32 = 0;
pub const STAT_COUNTER_F: &[u8; 2usize] = b"u\0";
pub const NETIF_MAX_HWADDR_LEN: u32 = 6;
pub const NETIF_NAMESIZE: u32 = 6;
pub const NETIF_FLAG_UP: u32 = 1;
pub const NETIF_FLAG_BROADCAST: u32 = 2;
pub const NETIF_FLAG_LINK_UP: u32 = 4;
pub const NETIF_FLAG_ETHARP: u32 = 8;
pub const NETIF_FLAG_ETHERNET: u32 = 16;
pub const NETIF_FLAG_IGMP: u32 = 32;
pub const NETIF_FLAG_MLD6: u32 = 64;
pub const NETIF_ADDR_IDX_MAX: u32 = 127;
pub const LWIP_NETIF_USE_HINTS: u32 = 0;
pub const NETIF_NO_INDEX: u32 = 0;
pub const LWIP_NSC_NONE: u32 = 0;
pub const LWIP_NSC_NETIF_ADDED: u32 = 1;
pub const LWIP_NSC_NETIF_REMOVED: u32 = 2;
pub const LWIP_NSC_LINK_CHANGED: u32 = 4;
pub const LWIP_NSC_STATUS_CHANGED: u32 = 8;
pub const LWIP_NSC_IPV4_ADDRESS_CHANGED: u32 = 16;
pub const LWIP_NSC_IPV4_GATEWAY_CHANGED: u32 = 32;
pub const LWIP_NSC_IPV4_NETMASK_CHANGED: u32 = 64;
pub const LWIP_NSC_IPV4_SETTINGS_CHANGED: u32 = 128;
pub const LWIP_NSC_IPV6_SET: u32 = 256;
pub const LWIP_NSC_IPV6_ADDR_STATE_CHANGED: u32 = 512;
pub const IP_HLEN: u32 = 20;
pub const IP_HLEN_MAX: u32 = 60;
pub const IP_RF: u32 = 32768;
pub const IP_DF: u32 = 16384;
pub const IP_MF: u32 = 8192;
pub const IP_OFFMASK: u32 = 8191;
pub const LWIP_IPV4_SRC_ROUTING: u32 = 0;
pub const IP6_MIN_MTU_LENGTH: u32 = 1280;
pub const IP6_HLEN: u32 = 40;
pub const IP6_NEXTH_HOPBYHOP: u32 = 0;
pub const IP6_NEXTH_TCP: u32 = 6;
pub const IP6_NEXTH_UDP: u32 = 17;
pub const IP6_NEXTH_ENCAPS: u32 = 41;
pub const IP6_NEXTH_ROUTING: u32 = 43;
pub const IP6_NEXTH_FRAGMENT: u32 = 44;
pub const IP6_NEXTH_ICMP6: u32 = 58;
pub const IP6_NEXTH_NONE: u32 = 59;
pub const IP6_NEXTH_DESTOPTS: u32 = 60;
pub const IP6_NEXTH_UDPLITE: u32 = 136;
pub const IP6_PAD1_OPTION: u32 = 0;
pub const IP6_PADN_OPTION: u32 = 1;
pub const IP6_ROUTER_ALERT_OPTION: u32 = 5;
pub const IP6_JUMBO_OPTION: u32 = 194;
pub const IP6_HOME_ADDRESS_OPTION: u32 = 201;
pub const IP6_ROUTER_ALERT_DLEN: u32 = 2;
pub const IP6_ROUTER_ALERT_VALUE_MLD: u32 = 0;
pub const IP6_OPT_HLEN: u32 = 2;
pub const IP6_HBH_HLEN: u32 = 2;
pub const IP6_DEST_HLEN: u32 = 2;
pub const IP6_ROUT_TYPE2: u32 = 2;
pub const IP6_ROUT_RPL: u32 = 3;
pub const IP6_FRAG_HLEN: u32 = 8;
pub const IP6_FRAG_OFFSET_MASK: u32 = 65528;
pub const IP6_FRAG_MORE_FLAG: u32 = 1;
pub const IP_PROTO_ICMP: u32 = 1;
pub const IP_PROTO_IGMP: u32 = 2;
pub const IP_PROTO_UDP: u32 = 17;
pub const IP_PROTO_UDPLITE: u32 = 136;
pub const IP_PROTO_TCP: u32 = 6;
pub const SOF_REUSEADDR: u32 = 4;
pub const SOF_KEEPALIVE: u32 = 8;
pub const SOF_BROADCAST: u32 = 32;
pub const SOF_INHERITED: u32 = 12;
pub const ICMP_ER: u32 = 0;
pub const ICMP_DUR: u32 = 3;
pub const ICMP_SQ: u32 = 4;
pub const ICMP_RD: u32 = 5;
pub const ICMP_ECHO: u32 = 8;
pub const ICMP_TE: u32 = 11;
pub const ICMP_PP: u32 = 12;
pub const ICMP_TS: u32 = 13;
pub const ICMP_TSR: u32 = 14;
pub const ICMP_IRQ: u32 = 15;
pub const ICMP_IR: u32 = 16;
pub const ICMP_AM: u32 = 17;
pub const ICMP_AMR: u32 = 18;
pub const ICMP6_HLEN: u32 = 8;
pub const LWIP_TCP_PCB_NUM_EXT_ARG_ID_INVALID: u32 = 255;
pub const TCP_ALLFLAGS: u32 = 65535;
pub const TF_ACK_DELAY: u32 = 1;
pub const TF_ACK_NOW: u32 = 2;
pub const TF_INFR: u32 = 4;
pub const TF_CLOSEPEND: u32 = 8;
pub const TF_RXCLOSED: u32 = 16;
pub const TF_FIN: u32 = 32;
pub const TF_NODELAY: u32 = 64;
pub const TF_NAGLEMEMERR: u32 = 128;
pub const TF_RTO: u32 = 2048;
pub const TCP_SNDQUEUELEN_OVERFLOW: u32 = 65532;
extern "C" {
    pub fn android_get_application_target_sdk_version() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn android_get_device_api_level() -> ::std::os::raw::c_int;
}
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_uint;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __uintptr_t = ::std::os::raw::c_ulong;
pub type int_least8_t = i8;
pub type uint_least8_t = u8;
pub type int_least16_t = i16;
pub type uint_least16_t = u16;
pub type int_least32_t = i32;
pub type uint_least32_t = u32;
pub type int_least64_t = i64;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type uint_fast8_t = u8;
pub type int_fast64_t = i64;
pub type uint_fast64_t = u64;
pub type int_fast16_t = i64;
pub type uint_fast16_t = u64;
pub type int_fast32_t = i64;
pub type uint_fast32_t = u64;
pub type uintmax_t = u64;
pub type intmax_t = i64;
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_old_dev_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_fsid_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fsid_t),
            "::",
            stringify!(val)
        )
    );
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_old_time_t = __kernel_long_t;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = ::std::os::raw::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __poll_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr_t {
    pub flags: u32,
    pub stack_base: *mut ::std::os::raw::c_void,
    pub stack_size: size_t,
    pub guard_size: size_t,
    pub sched_policy: i32,
    pub sched_priority: i32,
    pub __reserved: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).stack_base as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(stack_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).stack_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(stack_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).guard_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(guard_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).sched_policy as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(sched_policy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).sched_priority as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(sched_priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__reserved as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrier_t {
    pub __private: [i64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__private as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__private)
        )
    );
}
pub type pthread_barrierattr_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond_t {
    pub __private: [i32; 12usize],
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__private as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__private)
        )
    );
}
pub type pthread_condattr_t = ::std::os::raw::c_long;
pub type pthread_key_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex_t {
    pub __private: [i32; 10usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__private as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__private)
        )
    );
}
pub type pthread_mutexattr_t = ::std::os::raw::c_long;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlock_t {
    pub __private: [i32; 14usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__private as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__private)
        )
    );
}
pub type pthread_rwlockattr_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_spinlock_t {
    pub __private: i64,
}
#[test]
fn bindgen_test_layout_pthread_spinlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_spinlock_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_spinlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_spinlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_spinlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_spinlock_t>())).__private as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_spinlock_t),
            "::",
            stringify!(__private)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_long;
pub type __gid_t = __kernel_gid32_t;
pub type gid_t = __gid_t;
pub type __uid_t = __kernel_uid32_t;
pub type uid_t = __uid_t;
pub type __pid_t = __kernel_pid_t;
pub type pid_t = __pid_t;
pub type __id_t = u32;
pub type id_t = __id_t;
pub type blkcnt_t = ::std::os::raw::c_ulong;
pub type blksize_t = ::std::os::raw::c_ulong;
pub type caddr_t = __kernel_caddr_t;
pub type clock_t = __kernel_clock_t;
pub type __clockid_t = __kernel_clockid_t;
pub type clockid_t = __clockid_t;
pub type daddr_t = __kernel_daddr_t;
pub type fsblkcnt_t = ::std::os::raw::c_ulong;
pub type fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __mode_t = __kernel_mode_t;
pub type mode_t = __mode_t;
pub type __key_t = __kernel_key_t;
pub type key_t = __key_t;
pub type __ino_t = __kernel_ino_t;
pub type ino_t = __ino_t;
pub type ino64_t = u64;
pub type __nlink_t = u32;
pub type nlink_t = __nlink_t;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type timer_t = __timer_t;
pub type __suseconds_t = __kernel_suseconds_t;
pub type suseconds_t = __suseconds_t;
pub type __useconds_t = u32;
pub type useconds_t = __useconds_t;
pub type dev_t = u64;
pub type __time_t = __kernel_time_t;
pub type time_t = __time_t;
pub type off_t = i64;
pub type loff_t = off_t;
pub type off64_t = loff_t;
pub type __socklen_t = u32;
pub type socklen_t = __socklen_t;
pub type __va_list = [u64; 4usize];
pub type ssize_t = __kernel_ssize_t;
pub type uint_t = ::std::os::raw::c_uint;
pub type uint = ::std::os::raw::c_uint;
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type u_int32_t = u32;
pub type u_int16_t = u16;
pub type u_int8_t = u8;
pub type u_int64_t = u64;
pub type va_list = [u64; 4usize];
pub type __gnuc_va_list = [u64; 4usize];
pub type fpos_t = off_t;
pub type fpos64_t = off64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
    _unused: [u8; 0],
}
pub type FILE = __sFILE;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn clearerr(__fp: *mut FILE);
}
extern "C" {
    pub fn fclose(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feof(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __buf: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_int,
        __fp: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fprintf(
        __fp: *mut FILE,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__ch: ::std::os::raw::c_int, __fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __buf: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __count: ::std::os::raw::c_ulong,
        __fp: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fscanf(
        __fp: *mut FILE,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fwrite(
        __buf: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __count: ::std::os::raw::c_ulong,
        __fp: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn getc(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdelim(
        __line_ptr: *mut *mut ::std::os::raw::c_char,
        __line_length_ptr: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __fp: *mut FILE,
    ) -> ssize_t;
}
extern "C" {
    pub fn getline(
        __line_ptr: *mut *mut ::std::os::raw::c_char,
        __line_length_ptr: *mut size_t,
        __fp: *mut FILE,
    ) -> ssize_t;
}
extern "C" {
    pub fn perror(__msg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn printf(__fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__ch: ::std::os::raw::c_int, __fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__ch: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(__fp: *mut FILE);
}
extern "C" {
    pub fn scanf(__fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(__fp: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __fp: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __mode: ::std::os::raw::c_int,
        __size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__ch: ::std::os::raw::c_int, __fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __fp: *mut FILE,
        __fmt: *const ::std::os::raw::c_char,
        __args: [u64; 4usize],
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __fp: *const ::std::os::raw::c_char,
        __args: [u64; 4usize],
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __args: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        __args: [u64; 4usize],
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __prefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rename(
        __old_path: *const ::std::os::raw::c_char,
        __new_path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __old_dir_fd: ::std::os::raw::c_int,
        __old_path: *const ::std::os::raw::c_char,
        __new_dir_fd: ::std::os::raw::c_int,
        __new_path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        __fp: *mut FILE,
        __offset: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__fp: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fgetpos(__fp: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__fp: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseeko(
        __fp: *mut FILE,
        __offset: off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__fp: *mut FILE) -> off_t;
}
extern "C" {
    pub fn fgetpos64(__fp: *mut FILE, __pos: *mut fpos64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos64(__fp: *mut FILE, __pos: *const fpos64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseeko64(
        __fp: *mut FILE,
        __offset: off64_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello64(__fp: *mut FILE) -> off64_t;
}
extern "C" {
    pub fn fopen(
        __path: *const ::std::os::raw::c_char,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fopen64(
        __path: *const ::std::os::raw::c_char,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __path: *const ::std::os::raw::c_char,
        __mode: *const ::std::os::raw::c_char,
        __fp: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen64(
        __path: *const ::std::os::raw::c_char,
        __mode: *const ::std::os::raw::c_char,
        __fp: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpfile64() -> *mut FILE;
}
extern "C" {
    pub fn snprintf(
        __buf: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __fp: *mut FILE,
        __fmt: *const ::std::os::raw::c_char,
        __args: [u64; 4usize],
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __fmt: *const ::std::os::raw::c_char,
        __args: [u64; 4usize],
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __buf: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __fmt: *const ::std::os::raw::c_char,
        __args: [u64; 4usize],
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        __args: [u64; 4usize],
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__buf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __mode: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn flockfile(__fp: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__fp: *mut FILE);
}
extern "C" {
    pub fn getc_unlocked(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__ch: ::std::os::raw::c_int, __fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__ch: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fmemopen(
        __buf: *mut ::std::os::raw::c_void,
        __size: size_t,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __size_ptr: *mut size_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn asprintf(
        __s_ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetln(__fp: *mut FILE, __length_ptr: *mut size_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fpurge(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(
        __fp: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn setlinebuf(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        __s_ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        __args: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__fp: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__byte_count: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __item_count: ::std::os::raw::c_ulong,
        __item_size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __byte_count: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __item_count: size_t,
        __item_size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn memalign(
        __alignment: ::std::os::raw::c_ulong,
        __byte_count: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_usable_size(__ptr: *const ::std::os::raw::c_void) -> size_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mallinfo {
    pub arena: size_t,
    pub ordblks: size_t,
    pub smblks: size_t,
    pub hblks: size_t,
    pub hblkhd: size_t,
    pub usmblks: size_t,
    pub fsmblks: size_t,
    pub uordblks: size_t,
    pub fordblks: size_t,
    pub keepcost: size_t,
}
#[test]
fn bindgen_test_layout_mallinfo() {
    assert_eq!(
        ::std::mem::size_of::<mallinfo>(),
        80usize,
        concat!("Size of: ", stringify!(mallinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<mallinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(mallinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mallinfo>())).arena as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo),
            "::",
            stringify!(arena)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mallinfo>())).ordblks as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo),
            "::",
            stringify!(ordblks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mallinfo>())).smblks as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo),
            "::",
            stringify!(smblks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mallinfo>())).hblks as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo),
            "::",
            stringify!(hblks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mallinfo>())).hblkhd as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo),
            "::",
            stringify!(hblkhd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mallinfo>())).usmblks as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo),
            "::",
            stringify!(usmblks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mallinfo>())).fsmblks as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo),
            "::",
            stringify!(fsmblks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mallinfo>())).uordblks as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo),
            "::",
            stringify!(uordblks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mallinfo>())).fordblks as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo),
            "::",
            stringify!(fordblks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mallinfo>())).keepcost as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo),
            "::",
            stringify!(keepcost)
        )
    );
}
extern "C" {
    pub fn mallinfo() -> mallinfo;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mallinfo2 {
    pub arena: size_t,
    pub ordblks: size_t,
    pub smblks: size_t,
    pub hblks: size_t,
    pub hblkhd: size_t,
    pub usmblks: size_t,
    pub fsmblks: size_t,
    pub uordblks: size_t,
    pub fordblks: size_t,
    pub keepcost: size_t,
}
#[test]
fn bindgen_test_layout_mallinfo2() {
    assert_eq!(
        ::std::mem::size_of::<mallinfo2>(),
        80usize,
        concat!("Size of: ", stringify!(mallinfo2))
    );
    assert_eq!(
        ::std::mem::align_of::<mallinfo2>(),
        8usize,
        concat!("Alignment of ", stringify!(mallinfo2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mallinfo2>())).arena as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo2),
            "::",
            stringify!(arena)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mallinfo2>())).ordblks as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo2),
            "::",
            stringify!(ordblks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mallinfo2>())).smblks as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo2),
            "::",
            stringify!(smblks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mallinfo2>())).hblks as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo2),
            "::",
            stringify!(hblks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mallinfo2>())).hblkhd as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo2),
            "::",
            stringify!(hblkhd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mallinfo2>())).usmblks as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo2),
            "::",
            stringify!(usmblks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mallinfo2>())).fsmblks as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo2),
            "::",
            stringify!(fsmblks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mallinfo2>())).uordblks as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo2),
            "::",
            stringify!(uordblks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mallinfo2>())).fordblks as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo2),
            "::",
            stringify!(fordblks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mallinfo2>())).keepcost as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo2),
            "::",
            stringify!(keepcost)
        )
    );
}
extern "C" {
    pub fn malloc_info(
        __must_be_zero: ::std::os::raw::c_int,
        __fp: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
pub const HeapTaggingLevel_M_HEAP_TAGGING_LEVEL_NONE: HeapTaggingLevel = 0;
pub const HeapTaggingLevel_M_HEAP_TAGGING_LEVEL_TBI: HeapTaggingLevel = 1;
pub const HeapTaggingLevel_M_HEAP_TAGGING_LEVEL_ASYNC: HeapTaggingLevel = 2;
pub const HeapTaggingLevel_M_HEAP_TAGGING_LEVEL_SYNC: HeapTaggingLevel = 3;
pub type HeapTaggingLevel = ::std::os::raw::c_uint;
extern "C" {
    pub fn mallopt(
        __option: ::std::os::raw::c_int,
        __value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __malloc_hook: ::std::option::Option<
        unsafe extern "C" fn(
            __byte_count: size_t,
            __caller: *const ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >;
}
extern "C" {
    pub static mut __realloc_hook: ::std::option::Option<
        unsafe extern "C" fn(
            __ptr: *mut ::std::os::raw::c_void,
            __byte_count: size_t,
            __caller: *const ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >;
}
extern "C" {
    pub static mut __free_hook: ::std::option::Option<
        unsafe extern "C" fn(
            __ptr: *mut ::std::os::raw::c_void,
            __caller: *const ::std::os::raw::c_void,
        ),
    >;
}
extern "C" {
    pub static mut __memalign_hook: ::std::option::Option<
        unsafe extern "C" fn(
            __alignment: size_t,
            __byte_count: size_t,
            __caller: *const ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
pub type locale_t = *mut __locale_t;
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn atexit(__fn: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __fn: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__assignment: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __overwrite: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkostemp64(
        __template: *mut ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemp(
        __template: *mut ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemps64(
        __template: *mut ::std::os::raw::c_char,
        __suffix_length: ::std::os::raw::c_int,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemps(
        __template: *mut ::std::os::raw::c_char,
        __suffix_length: ::std::os::raw::c_int,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemp64(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps64(
        __template: *mut ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strtol(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoll(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: size_t,
        __size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strtod(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtold(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtoul_l(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn atoi(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn realpath(
        __path: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __comparator: ::std::option::Option<
            unsafe extern "C" fn(
                __lhs: *const ::std::os::raw::c_void,
                __rhs: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __comparator: ::std::option::Option<
            unsafe extern "C" fn(
                __lhs: *const ::std::os::raw::c_void,
                __rhs: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn arc4random() -> u32;
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: u32) -> u32;
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __n: size_t);
}
extern "C" {
    pub fn rand_r(__seed_ptr: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn srand48(__seed: ::std::os::raw::c_long);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __state: *mut ::std::os::raw::c_char,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__state: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getpt() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_openpt(__flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptsname(__fd: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ptsname_r(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlockpt(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __option: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __value_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn div(__numerator: ::std::os::raw::c_int, __denominator: ::std::os::raw::c_int) -> div_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn ldiv(
        __numerator: ::std::os::raw::c_long,
        __denominator: ::std::os::raw::c_long,
    ) -> ldiv_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn lldiv(
        __numerator: ::std::os::raw::c_longlong,
        __denominator: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn getloadavg(__averages: *mut f64, __n: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getprogname() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn setprogname(__name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(
        __dst: *mut wchar_t,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn mbtowc(
        __wc_ptr: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__dst: *mut ::std::os::raw::c_char, __wc: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcstombs(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const wchar_t,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> size_t;
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtof(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn atof(__s: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn grantpt(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strtoll_l(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull_l(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtold_l(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
        __l: locale_t,
    ) -> u128;
}
extern "C" {
    pub fn strtod_l(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
        __l: locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtof_l(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
        __l: locale_t,
    ) -> f32;
}
extern "C" {
    pub fn strtol_l(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
        arg1: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> ::std::os::raw::c_long;
}
pub type u8_t = u8;
pub type s8_t = i8;
pub type u16_t = u16;
pub type s16_t = i16;
pub type u32_t = u32;
pub type s32_t = i32;
pub type u64_t = u64;
pub type s64_t = i64;
pub type mem_ptr_t = usize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(__i: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numerator: intmax_t, __denominator: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __s: *const wchar_t,
        __end_ptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __s: *const wchar_t,
        __end_ptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_timespec {
    pub tv_sec: __kernel_time64_t,
    pub tv_nsec: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___kernel_timespec() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_timespec>(),
        16usize,
        concat!("Size of: ", stringify!(__kernel_timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_itimerspec {
    pub it_interval: __kernel_timespec,
    pub it_value: __kernel_timespec,
}
#[test]
fn bindgen_test_layout___kernel_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(__kernel_itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_old_timespec {
    pub tv_sec: __kernel_old_time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout___kernel_old_timespec() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_old_timespec>(),
        16usize,
        concat!("Size of: ", stringify!(__kernel_old_timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_old_timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_old_timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_old_timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_old_timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_old_timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_old_timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_sock_timeval {
    pub tv_sec: __s64,
    pub tv_usec: __s64,
}
#[test]
fn bindgen_test_layout___kernel_sock_timeval() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_sock_timeval>(),
        16usize,
        concat!("Size of: ", stringify!(__kernel_sock_timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_sock_timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_sock_timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_sock_timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_sock_timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_sock_timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_sock_timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __kernel_old_time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __kernel_old_time_t,
    pub tv_usec: __kernel_suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    assert_eq!(
        ::std::mem::size_of::<itimerval>(),
        32usize,
        concat!("Size of: ", stringify!(itimerval))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerval>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerval>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerval>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(
        ::std::mem::size_of::<timezone>(),
        8usize,
        concat!("Size of: ", stringify!(timezone))
    );
    assert_eq!(
        ::std::mem::align_of::<timezone>(),
        4usize,
        concat!("Alignment of ", stringify!(timezone))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timezone>())).tz_minuteswest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_minuteswest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timezone>())).tz_dsttime as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_dsttime)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct sigcontext {
    pub fault_address: __u64,
    pub regs: [__u64; 31usize],
    pub sp: __u64,
    pub pc: __u64,
    pub pstate: __u64,
    pub __bindgen_padding_0: [u8; 8usize],
    pub __reserved: [__u8; 4096usize],
}
#[test]
fn bindgen_test_layout_sigcontext() {
    assert_eq!(
        ::std::mem::size_of::<sigcontext>(),
        4384usize,
        concat!("Size of: ", stringify!(sigcontext))
    );
    assert_eq!(
        ::std::mem::align_of::<sigcontext>(),
        16usize,
        concat!("Alignment of ", stringify!(sigcontext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).fault_address as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(fault_address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).regs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(regs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).sp as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).pc as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(pc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).pstate as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(pstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).__reserved as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _aarch64_ctx {
    pub magic: __u32,
    pub size: __u32,
}
#[test]
fn bindgen_test_layout__aarch64_ctx() {
    assert_eq!(
        ::std::mem::size_of::<_aarch64_ctx>(),
        8usize,
        concat!("Size of: ", stringify!(_aarch64_ctx))
    );
    assert_eq!(
        ::std::mem::align_of::<_aarch64_ctx>(),
        4usize,
        concat!("Alignment of ", stringify!(_aarch64_ctx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_aarch64_ctx>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_aarch64_ctx),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_aarch64_ctx>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_aarch64_ctx),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct fpsimd_context {
    pub head: _aarch64_ctx,
    pub fpsr: __u32,
    pub fpcr: __u32,
    pub vregs: [__uint128_t; 32usize],
}
#[test]
fn bindgen_test_layout_fpsimd_context() {
    assert_eq!(
        ::std::mem::size_of::<fpsimd_context>(),
        528usize,
        concat!("Size of: ", stringify!(fpsimd_context))
    );
    assert_eq!(
        ::std::mem::align_of::<fpsimd_context>(),
        16usize,
        concat!("Alignment of ", stringify!(fpsimd_context))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpsimd_context>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpsimd_context),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpsimd_context>())).fpsr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fpsimd_context),
            "::",
            stringify!(fpsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpsimd_context>())).fpcr as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(fpsimd_context),
            "::",
            stringify!(fpcr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpsimd_context>())).vregs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fpsimd_context),
            "::",
            stringify!(vregs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esr_context {
    pub head: _aarch64_ctx,
    pub esr: __u64,
}
#[test]
fn bindgen_test_layout_esr_context() {
    assert_eq!(
        ::std::mem::size_of::<esr_context>(),
        16usize,
        concat!("Size of: ", stringify!(esr_context))
    );
    assert_eq!(
        ::std::mem::align_of::<esr_context>(),
        8usize,
        concat!("Alignment of ", stringify!(esr_context))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<esr_context>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(esr_context),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<esr_context>())).esr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(esr_context),
            "::",
            stringify!(esr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct extra_context {
    pub head: _aarch64_ctx,
    pub datap: __u64,
    pub size: __u32,
    pub __reserved: [__u32; 3usize],
}
#[test]
fn bindgen_test_layout_extra_context() {
    assert_eq!(
        ::std::mem::size_of::<extra_context>(),
        32usize,
        concat!("Size of: ", stringify!(extra_context))
    );
    assert_eq!(
        ::std::mem::align_of::<extra_context>(),
        8usize,
        concat!("Alignment of ", stringify!(extra_context))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<extra_context>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(extra_context),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<extra_context>())).datap as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(extra_context),
            "::",
            stringify!(datap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<extra_context>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(extra_context),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<extra_context>())).__reserved as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(extra_context),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sve_context {
    pub head: _aarch64_ctx,
    pub vl: __u16,
    pub __reserved: [__u16; 3usize],
}
#[test]
fn bindgen_test_layout_sve_context() {
    assert_eq!(
        ::std::mem::size_of::<sve_context>(),
        16usize,
        concat!("Size of: ", stringify!(sve_context))
    );
    assert_eq!(
        ::std::mem::align_of::<sve_context>(),
        4usize,
        concat!("Alignment of ", stringify!(sve_context))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sve_context>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sve_context),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sve_context>())).vl as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sve_context),
            "::",
            stringify!(vl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sve_context>())).__reserved as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(sve_context),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigset_t {
    pub sig: [::std::os::raw::c_ulong; 1usize],
}
#[test]
fn bindgen_test_layout_sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<sigset_t>(),
        8usize,
        concat!("Size of: ", stringify!(sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigset_t>())).sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigset_t),
            "::",
            stringify!(sig)
        )
    );
}
pub type old_sigset_t = ::std::os::raw::c_ulong;
pub type __signalfn_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __sighandler_t = __signalfn_t;
pub type __restorefn_t = ::std::option::Option<unsafe extern "C" fn()>;
pub type __sigrestore_t = __restorefn_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_sigaction {
    pub sa_handler: __sighandler_t,
    pub sa_flags: ::std::os::raw::c_ulong,
    pub sa_restorer: __sigrestore_t,
    pub sa_mask: sigset_t,
}
#[test]
fn bindgen_test_layout___kernel_sigaction() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_sigaction>(),
        32usize,
        concat!("Size of: ", stringify!(__kernel_sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_sigaction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_sigaction>())).sa_handler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_sigaction),
            "::",
            stringify!(sa_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_sigaction>())).sa_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_sigaction>())).sa_restorer as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_sigaction),
            "::",
            stringify!(sa_restorer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_sigaction>())).sa_mask as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_flags: ::std::os::raw::c_int,
    pub ss_size: size_t,
}
#[test]
fn bindgen_test_layout_sigaltstack() {
    assert_eq!(
        ::std::mem::size_of::<sigaltstack>(),
        24usize,
        concat!("Size of: ", stringify!(sigaltstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaltstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaltstack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaltstack>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaltstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaltstack>())).ss_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaltstack),
            "::",
            stringify!(ss_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaltstack>())).ss_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaltstack),
            "::",
            stringify!(ss_size)
        )
    );
}
pub type stack_t = sigaltstack;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(
        ::std::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sival_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sival_ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
pub type sigval_t = sigval;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sifields {
    pub _kill: __sifields__bindgen_ty_1,
    pub _timer: __sifields__bindgen_ty_2,
    pub _rt: __sifields__bindgen_ty_3,
    pub _sigchld: __sifields__bindgen_ty_4,
    pub _sigfault: __sifields__bindgen_ty_5,
    pub _sigpoll: __sifields__bindgen_ty_6,
    pub _sigsys: __sifields__bindgen_ty_7,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_1 {
    pub _pid: __kernel_pid_t,
    pub _uid: __kernel_uid32_t,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__sifields__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__sifields__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields__bindgen_ty_1>()))._pid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_1),
            "::",
            stringify!(_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields__bindgen_ty_1>()))._uid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_1),
            "::",
            stringify!(_uid)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sifields__bindgen_ty_2 {
    pub _tid: __kernel_timer_t,
    pub _overrun: ::std::os::raw::c_int,
    pub _sigval: sigval_t,
    pub _sys_private: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_2>(),
        24usize,
        concat!("Size of: ", stringify!(__sifields__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__sifields__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields__bindgen_ty_2>()))._tid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_2),
            "::",
            stringify!(_tid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_2>()))._overrun as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_2),
            "::",
            stringify!(_overrun)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_2>()))._sigval as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_2),
            "::",
            stringify!(_sigval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_2>()))._sys_private as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_2),
            "::",
            stringify!(_sys_private)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sifields__bindgen_ty_3 {
    pub _pid: __kernel_pid_t,
    pub _uid: __kernel_uid32_t,
    pub _sigval: sigval_t,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_3>(),
        16usize,
        concat!("Size of: ", stringify!(__sifields__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(__sifields__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields__bindgen_ty_3>()))._pid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_3),
            "::",
            stringify!(_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields__bindgen_ty_3>()))._uid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_3),
            "::",
            stringify!(_uid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_3>()))._sigval as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_3),
            "::",
            stringify!(_sigval)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_4 {
    pub _pid: __kernel_pid_t,
    pub _uid: __kernel_uid32_t,
    pub _status: ::std::os::raw::c_int,
    pub _utime: __kernel_clock_t,
    pub _stime: __kernel_clock_t,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_4>(),
        32usize,
        concat!("Size of: ", stringify!(__sifields__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(__sifields__bindgen_ty_4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields__bindgen_ty_4>()))._pid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_4),
            "::",
            stringify!(_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields__bindgen_ty_4>()))._uid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_4),
            "::",
            stringify!(_uid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_4>()))._status as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_4),
            "::",
            stringify!(_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields__bindgen_ty_4>()))._utime as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_4),
            "::",
            stringify!(_utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields__bindgen_ty_4>()))._stime as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_4),
            "::",
            stringify!(_stime)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sifields__bindgen_ty_5 {
    pub _addr: *mut ::std::os::raw::c_void,
    pub __bindgen_anon_1: __sifields__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sifields__bindgen_ty_5__bindgen_ty_1 {
    pub _trapno: ::std::os::raw::c_int,
    pub _addr_lsb: ::std::os::raw::c_short,
    pub _addr_bnd: __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    pub _addr_pkey: __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2,
    pub _perf: __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _dummy_bnd: [::std::os::raw::c_char; 8usize],
    pub _lower: *mut ::std::os::raw::c_void,
    pub _upper: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>()))
                ._dummy_bnd as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_dummy_bnd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>()))._lower
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_lower)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>()))._upper
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_upper)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2 {
    pub _dummy_pkey: [::std::os::raw::c_char; 8usize],
    pub _pkey: __u32,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2>()))
                ._dummy_pkey as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_dummy_pkey)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2>()))._pkey
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_pkey)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3 {
    pub _data: ::std::os::raw::c_ulong,
    pub _type: __u32,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3>()))._data
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3>()))._type
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(_type)
        )
    );
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_5__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_5__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_5__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1>()))._trapno as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_trapno)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1>()))._addr_lsb as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_addr_lsb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1>()))._addr_bnd as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_addr_bnd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1>()))._addr_pkey
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_addr_pkey)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1>()))._perf as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_perf)
        )
    );
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_5>(),
        32usize,
        concat!("Size of: ", stringify!(__sifields__bindgen_ty_5))
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_5>(),
        8usize,
        concat!("Alignment of ", stringify!(__sifields__bindgen_ty_5))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields__bindgen_ty_5>()))._addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5),
            "::",
            stringify!(_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_6 {
    pub _band: ::std::os::raw::c_long,
    pub _fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_6>(),
        16usize,
        concat!("Size of: ", stringify!(__sifields__bindgen_ty_6))
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_6>(),
        8usize,
        concat!("Alignment of ", stringify!(__sifields__bindgen_ty_6))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields__bindgen_ty_6>()))._band as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_6),
            "::",
            stringify!(_band)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields__bindgen_ty_6>()))._fd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_6),
            "::",
            stringify!(_fd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_7 {
    pub _call_addr: *mut ::std::os::raw::c_void,
    pub _syscall: ::std::os::raw::c_int,
    pub _arch: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_7() {
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_7>(),
        16usize,
        concat!("Size of: ", stringify!(__sifields__bindgen_ty_7))
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_7>(),
        8usize,
        concat!("Alignment of ", stringify!(__sifields__bindgen_ty_7))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_7>()))._call_addr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_7),
            "::",
            stringify!(_call_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_7>()))._syscall as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_7),
            "::",
            stringify!(_syscall)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields__bindgen_ty_7>()))._arch as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_7),
            "::",
            stringify!(_arch)
        )
    );
}
#[test]
fn bindgen_test_layout___sifields() {
    assert_eq!(
        ::std::mem::size_of::<__sifields>(),
        32usize,
        concat!("Size of: ", stringify!(__sifields))
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields>(),
        8usize,
        concat!("Alignment of ", stringify!(__sifields))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields>()))._kill as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields),
            "::",
            stringify!(_kill)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields>()))._timer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields),
            "::",
            stringify!(_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields>()))._rt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields),
            "::",
            stringify!(_rt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields>()))._sigchld as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields),
            "::",
            stringify!(_sigchld)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields>()))._sigfault as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields),
            "::",
            stringify!(_sigfault)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields>()))._sigpoll as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields),
            "::",
            stringify!(_sigpoll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields>()))._sigsys as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields),
            "::",
            stringify!(_sigsys)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo {
    pub __bindgen_anon_1: siginfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo__bindgen_ty_1 {
    pub __bindgen_anon_1: siginfo__bindgen_ty_1__bindgen_ty_1,
    pub _si_pad: [::std::os::raw::c_int; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo__bindgen_ty_1__bindgen_ty_1 {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub _sifields: __sifields,
}
#[test]
fn bindgen_test_layout_siginfo__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<siginfo__bindgen_ty_1__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(siginfo__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_1>())).si_signo as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_1>())).si_errno as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_1>())).si_code as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_1>()))._sifields as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_sifields)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<siginfo__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(siginfo__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(siginfo__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo__bindgen_ty_1>()))._si_pad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1),
            "::",
            stringify!(_si_pad)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo() {
    assert_eq!(
        ::std::mem::size_of::<siginfo>(),
        128usize,
        concat!("Size of: ", stringify!(siginfo))
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo>(),
        8usize,
        concat!("Alignment of ", stringify!(siginfo))
    );
}
pub type siginfo_t = siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_value: sigval_t,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_notify: ::std::os::raw::c_int,
    pub _sigev_un: sigevent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigevent__bindgen_ty_1 {
    pub _pad: [::std::os::raw::c_int; 12usize],
    pub _tid: ::std::os::raw::c_int,
    pub _sigev_thread: sigevent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub _function: ::std::option::Option<unsafe extern "C" fn(arg1: sigval_t)>,
    pub _attribute: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sigevent__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigevent__bindgen_ty_1__bindgen_ty_1>()))._function as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigevent__bindgen_ty_1__bindgen_ty_1>()))._attribute as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_attribute)
        )
    );
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sigevent__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(sigevent__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent__bindgen_ty_1>()))._pad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent__bindgen_ty_1>()))._tid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_tid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigevent__bindgen_ty_1>()))._sigev_thread as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_sigev_thread)
        )
    );
}
#[test]
fn bindgen_test_layout_sigevent() {
    assert_eq!(
        ::std::mem::size_of::<sigevent>(),
        64usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_signo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_notify as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>()))._sigev_un as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(_sigev_un)
        )
    );
}
pub type sigevent_t = sigevent;
pub type sig_atomic_t = ::std::os::raw::c_int;
pub type sig_t = __sighandler_t;
pub type sighandler_t = __sighandler_t;
pub type sigset64_t = sigset_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub sa_flags: ::std::os::raw::c_int,
    pub __bindgen_anon_1: sigaction__bindgen_ty_1,
    pub sa_mask: sigset_t,
    pub sa_restorer: ::std::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigaction__bindgen_ty_1 {
    pub sa_handler: sighandler_t,
    pub sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut siginfo,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout_sigaction__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sigaction__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(sigaction__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigaction__bindgen_ty_1>())).sa_handler as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction__bindgen_ty_1),
            "::",
            stringify!(sa_handler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigaction__bindgen_ty_1>())).sa_sigaction as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction__bindgen_ty_1),
            "::",
            stringify!(sa_sigaction)
        )
    );
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(
        ::std::mem::size_of::<sigaction>(),
        32usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_restorer as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_restorer)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction64 {
    pub sa_flags: ::std::os::raw::c_int,
    pub __bindgen_anon_1: sigaction64__bindgen_ty_1,
    pub sa_mask: sigset_t,
    pub sa_restorer: ::std::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigaction64__bindgen_ty_1 {
    pub sa_handler: sighandler_t,
    pub sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut siginfo,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout_sigaction64__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sigaction64__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(sigaction64__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction64__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction64__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigaction64__bindgen_ty_1>())).sa_handler as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction64__bindgen_ty_1),
            "::",
            stringify!(sa_handler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigaction64__bindgen_ty_1>())).sa_sigaction as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction64__bindgen_ty_1),
            "::",
            stringify!(sa_sigaction)
        )
    );
}
#[test]
fn bindgen_test_layout_sigaction64() {
    assert_eq!(
        ::std::mem::size_of::<sigaction64>(),
        32usize,
        concat!("Size of: ", stringify!(sigaction64))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction64>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction64>())).sa_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction64),
            "::",
            stringify!(sa_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction64>())).sa_mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction64),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction64>())).sa_restorer as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction64),
            "::",
            stringify!(sa_restorer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct user_regs_struct {
    pub regs: [u64; 31usize],
    pub sp: u64,
    pub pc: u64,
    pub pstate: u64,
}
#[test]
fn bindgen_test_layout_user_regs_struct() {
    assert_eq!(
        ::std::mem::size_of::<user_regs_struct>(),
        272usize,
        concat!("Size of: ", stringify!(user_regs_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<user_regs_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(user_regs_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_regs_struct>())).regs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(user_regs_struct),
            "::",
            stringify!(regs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_regs_struct>())).sp as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(user_regs_struct),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_regs_struct>())).pc as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(user_regs_struct),
            "::",
            stringify!(pc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_regs_struct>())).pstate as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(user_regs_struct),
            "::",
            stringify!(pstate)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct user_fpsimd_struct {
    pub vregs: [__uint128_t; 32usize],
    pub fpsr: u32,
    pub fpcr: u32,
}
#[test]
fn bindgen_test_layout_user_fpsimd_struct() {
    assert_eq!(
        ::std::mem::size_of::<user_fpsimd_struct>(),
        528usize,
        concat!("Size of: ", stringify!(user_fpsimd_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<user_fpsimd_struct>(),
        16usize,
        concat!("Alignment of ", stringify!(user_fpsimd_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_fpsimd_struct>())).vregs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(user_fpsimd_struct),
            "::",
            stringify!(vregs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_fpsimd_struct>())).fpsr as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(user_fpsimd_struct),
            "::",
            stringify!(fpsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_fpsimd_struct>())).fpcr as *const _ as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(user_fpsimd_struct),
            "::",
            stringify!(fpcr)
        )
    );
}
pub type greg_t = ::std::os::raw::c_ulong;
pub type gregset_t = [greg_t; 34usize];
pub type fpregset_t = user_fpsimd_struct;
pub type mcontext_t = sigcontext;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct ucontext {
    pub uc_flags: ::std::os::raw::c_ulong,
    pub uc_link: *mut ucontext,
    pub uc_stack: stack_t,
    pub __bindgen_anon_1: ucontext__bindgen_ty_1,
    pub __padding: [::std::os::raw::c_char; 120usize],
    pub __bindgen_padding_0: u64,
    pub uc_mcontext: mcontext_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ucontext__bindgen_ty_1 {
    pub uc_sigmask: sigset_t,
    pub uc_sigmask64: sigset64_t,
}
#[test]
fn bindgen_test_layout_ucontext__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ucontext__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(ucontext__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ucontext__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ucontext__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ucontext__bindgen_ty_1>())).uc_sigmask as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext__bindgen_ty_1),
            "::",
            stringify!(uc_sigmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ucontext__bindgen_ty_1>())).uc_sigmask64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext__bindgen_ty_1),
            "::",
            stringify!(uc_sigmask64)
        )
    );
}
#[test]
fn bindgen_test_layout_ucontext() {
    assert_eq!(
        ::std::mem::size_of::<ucontext>(),
        4560usize,
        concat!("Size of: ", stringify!(ucontext))
    );
    assert_eq!(
        ::std::mem::align_of::<ucontext>(),
        16usize,
        concat!("Alignment of ", stringify!(ucontext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext>())).uc_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext),
            "::",
            stringify!(uc_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext>())).uc_link as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext),
            "::",
            stringify!(uc_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext>())).uc_stack as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext),
            "::",
            stringify!(uc_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext>())).__padding as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext),
            "::",
            stringify!(__padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext>())).uc_mcontext as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext),
            "::",
            stringify!(uc_mcontext)
        )
    );
}
pub type ucontext_t = ucontext;
extern "C" {
    pub fn __libc_current_sigrtmin() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __libc_current_sigrtmax() -> ::std::os::raw::c_int;
}
extern "C" {
    pub static sys_siglist: [*const ::std::os::raw::c_char; 65usize];
}
extern "C" {
    pub static sys_signame: [*const ::std::os::raw::c_char; 65usize];
}
extern "C" {
    pub fn sigaction(
        __signal: ::std::os::raw::c_int,
        __new_action: *const sigaction,
        __old_action: *mut sigaction,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaction64(
        __signal: ::std::os::raw::c_int,
        __new_action: *const sigaction64,
        __old_action: *mut sigaction64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn siginterrupt(
        __signal: ::std::os::raw::c_int,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn signal(__signal: ::std::os::raw::c_int, __handler: sighandler_t) -> sighandler_t;
}
extern "C" {
    pub fn sigaddset(
        __set: *mut sigset_t,
        __signal: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaddset64(
        __set: *mut sigset64_t,
        __signal: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigdelset(
        __set: *mut sigset_t,
        __signal: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigdelset64(
        __set: *mut sigset64_t,
        __signal: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigemptyset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigemptyset64(__set: *mut sigset64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigfillset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigfillset64(__set: *mut sigset64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigismember(
        __set: *const sigset_t,
        __signal: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigismember64(
        __set: *const sigset64_t,
        __signal: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigpending(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigpending64(__set: *mut sigset64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigprocmask(
        __how: ::std::os::raw::c_int,
        __new_set: *const sigset_t,
        __old_set: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigprocmask64(
        __how: ::std::os::raw::c_int,
        __new_set: *const sigset64_t,
        __old_set: *mut sigset64_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigsuspend(__mask: *const sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigsuspend64(__mask: *const sigset64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwait(
        __set: *const sigset_t,
        __signal: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwait64(
        __set: *const sigset64_t,
        __signal: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sighold(__signal: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigignore(__signal: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigpause(__signal: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigrelse(__signal: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigset(__signal: ::std::os::raw::c_int, __handler: sighandler_t) -> sighandler_t;
}
extern "C" {
    pub fn raise(__signal: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kill(__pid: pid_t, __signal: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn killpg(
        __pgrp: ::std::os::raw::c_int,
        __signal: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tgkill(
        __tgid: ::std::os::raw::c_int,
        __tid: ::std::os::raw::c_int,
        __signal: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaltstack(
        __new_signal_stack: *const stack_t,
        __old_signal_stack: *mut stack_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psiginfo(__info: *const siginfo_t, __msg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn psignal(__signal: ::std::os::raw::c_int, __msg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn pthread_kill(
        __pthread: pthread_t,
        __signal: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_sigmask(
        __how: ::std::os::raw::c_int,
        __new_set: *const sigset_t,
        __old_set: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_sigmask64(
        __how: ::std::os::raw::c_int,
        __new_set: *const sigset64_t,
        __old_set: *mut sigset64_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigqueue(
        __pid: pid_t,
        __signal: ::std::os::raw::c_int,
        __value: sigval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigtimedwait(
        __set: *const sigset_t,
        __info: *mut siginfo_t,
        __timeout: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigtimedwait64(
        __set: *const sigset64_t,
        __info: *mut siginfo_t,
        __timeout: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwaitinfo(__set: *const sigset_t, __info: *mut siginfo_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwaitinfo64(__set: *const sigset64_t, __info: *mut siginfo_t)
        -> ::std::os::raw::c_int;
}
pub type fd_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
extern "C" {
    pub fn __FD_CLR_chk(arg1: ::std::os::raw::c_int, arg2: *mut fd_set, arg3: size_t);
}
extern "C" {
    pub fn __FD_SET_chk(arg1: ::std::os::raw::c_int, arg2: *mut fd_set, arg3: size_t);
}
extern "C" {
    pub fn __FD_ISSET_chk(
        arg1: ::std::os::raw::c_int,
        arg2: *const fd_set,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn select(
        __max_fd_plus_one: ::std::os::raw::c_int,
        __read_fds: *mut fd_set,
        __write_fds: *mut fd_set,
        __exception_fds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __max_fd_plus_one: ::std::os::raw::c_int,
        __read_fds: *mut fd_set,
        __write_fds: *mut fd_set,
        __exception_fds: *mut fd_set,
        __timeout: *const timespec,
        __mask: *const sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect64(
        __max_fd_plus_one: ::std::os::raw::c_int,
        __read_fds: *mut fd_set,
        __write_fds: *mut fd_set,
        __exception_fds: *mut fd_set,
        __timeout: *const timespec,
        __mask: *const sigset64_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcntl(
        __fd: ::std::os::raw::c_int,
        __cmd: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getopt(
        __argc: ::std::os::raw::c_int,
        __argv: *const *mut ::std::os::raw::c_char,
        __options: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut optind: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut opterr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optopt: ::std::os::raw::c_int;
}
extern "C" {
    pub fn ioctl(
        __fd: ::std::os::raw::c_int,
        __request: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lockf(
        __fd: ::std::os::raw::c_int,
        __cmd: ::std::os::raw::c_int,
        __length: off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lockf64(
        __fd: ::std::os::raw::c_int,
        __cmd: ::std::os::raw::c_int,
        __length: off64_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sysconf(__name: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub static mut environ: *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn fork() -> pid_t;
}
extern "C" {
    pub fn vfork() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpid() -> pid_t;
}
extern "C" {
    pub fn gettid() -> pid_t;
}
extern "C" {
    pub fn getpgid(__pid: pid_t) -> pid_t;
}
extern "C" {
    pub fn setpgid(__pid: pid_t, __pgid: pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getppid() -> pid_t;
}
extern "C" {
    pub fn getpgrp() -> pid_t;
}
extern "C" {
    pub fn setpgrp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsid(__pid: pid_t) -> pid_t;
}
extern "C" {
    pub fn setsid() -> pid_t;
}
extern "C" {
    pub fn execv(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execvp(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execvpe(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execve(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execl(
        __path: *const ::std::os::raw::c_char,
        __arg0: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execlp(
        __file: *const ::std::os::raw::c_char,
        __arg0: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execle(
        __path: *const ::std::os::raw::c_char,
        __arg0: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fexecve(
        __fd: ::std::os::raw::c_int,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nice(__incr: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setegid(__gid: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seteuid(__uid: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setgid(__gid: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setregid(__rgid: gid_t, __egid: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setresgid(__rgid: gid_t, __egid: gid_t, __sgid: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setresuid(__ruid: uid_t, __euid: uid_t, __suid: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setreuid(__ruid: uid_t, __euid: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setuid(__uid: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getuid() -> uid_t;
}
extern "C" {
    pub fn geteuid() -> uid_t;
}
extern "C" {
    pub fn getgid() -> gid_t;
}
extern "C" {
    pub fn getegid() -> gid_t;
}
extern "C" {
    pub fn getgroups(__size: ::std::os::raw::c_int, __list: *mut gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setgroups(__size: size_t, __list: *const gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getresuid(
        __ruid: *mut uid_t,
        __euid: *mut uid_t,
        __suid: *mut uid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getresgid(
        __rgid: *mut gid_t,
        __egid: *mut gid_t,
        __sgid: *mut gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getlogin() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getlogin_r(
        __buffer: *mut ::std::os::raw::c_char,
        __buffer_size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fpathconf(
        __fd: ::std::os::raw::c_int,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn pathconf(
        __path: *const ::std::os::raw::c_char,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn access(
        __path: *const ::std::os::raw::c_char,
        __mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faccessat(
        __dirfd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __mode: ::std::os::raw::c_int,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn link(
        __old_path: *const ::std::os::raw::c_char,
        __new_path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn linkat(
        __old_dir_fd: ::std::os::raw::c_int,
        __old_path: *const ::std::os::raw::c_char,
        __new_dir_fd: ::std::os::raw::c_int,
        __new_path: *const ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlink(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlinkat(
        __dirfd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchdir(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pipe(__fds: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chroot(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn symlink(
        __old_path: *const ::std::os::raw::c_char,
        __new_path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn symlinkat(
        __old_path: *const ::std::os::raw::c_char,
        __new_dir_fd: ::std::os::raw::c_int,
        __new_path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlink(
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __buf_size: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn readlinkat(
        __dir_fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __buf_size: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn chown(
        __path: *const ::std::os::raw::c_char,
        __owner: uid_t,
        __group: gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchown(
        __fd: ::std::os::raw::c_int,
        __owner: uid_t,
        __group: gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchownat(
        __dir_fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __owner: uid_t,
        __group: gid_t,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lchown(
        __path: *const ::std::os::raw::c_char,
        __owner: uid_t,
        __group: gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getcwd(
        __buf: *mut ::std::os::raw::c_char,
        __size: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sync();
}
extern "C" {
    pub fn close(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn read(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __count: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn write(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __count: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn dup(__old_fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup2(
        __old_fd: ::std::os::raw::c_int,
        __new_fd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup3(
        __old_fd: ::std::os::raw::c_int,
        __new_fd: ::std::os::raw::c_int,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsync(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdatasync(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn truncate(
        __path: *const ::std::os::raw::c_char,
        __length: off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lseek(
        __fd: ::std::os::raw::c_int,
        __offset: off_t,
        __whence: ::std::os::raw::c_int,
    ) -> off_t;
}
extern "C" {
    pub fn pread(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __count: size_t,
        __offset: off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn pwrite(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __count: size_t,
        __offset: off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn ftruncate(__fd: ::std::os::raw::c_int, __length: off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn truncate64(
        __path: *const ::std::os::raw::c_char,
        __length: off64_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lseek64(
        __fd: ::std::os::raw::c_int,
        __offset: off64_t,
        __whence: ::std::os::raw::c_int,
    ) -> off64_t;
}
extern "C" {
    pub fn pread64(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __count: size_t,
        __offset: off64_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn pwrite64(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __count: size_t,
        __offset: off64_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn ftruncate64(__fd: ::std::os::raw::c_int, __length: off64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pause() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alarm(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn sleep(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn usleep(__microseconds: useconds_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostname(
        __buf: *mut ::std::os::raw::c_char,
        __buf_size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostname(__name: *const ::std::os::raw::c_char, __n: size_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn brk(__addr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sbrk(__increment: isize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn isatty(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyname(__fd: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ttyname_r(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buf_size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acct(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpagesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn syscall(__number: ::std::os::raw::c_long, ...) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn daemon(
        __no_chdir: ::std::os::raw::c_int,
        __no_close: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcgetpgrp(__fd: ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    pub fn tcsetpgrp(__fd: ::std::os::raw::c_int, __pid: pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdomainname(
        __buf: *mut ::std::os::raw::c_char,
        __buf_size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setdomainname(
        __name: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swab(
        __src: *const ::std::os::raw::c_void,
        __dst: *mut ::std::os::raw::c_void,
        __byte_count: ssize_t,
    );
}
extern "C" {
    pub static mut _ctype_: *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn isalnum_l(__ch: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha_l(__ch: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank_l(__ch: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl_l(__ch: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit_l(__ch: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph_l(__ch: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower_l(__ch: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint_l(__ch: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct_l(__ch: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace_l(__ch: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper_l(__ch: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit_l(__ch: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower_l(__ch: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper_l(__ch: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @}"]
    pub fn lwip_init();
}
pub type tcpwnd_size_t = u16_t;
pub const tcp_state_CLOSED: tcp_state = 0;
pub const tcp_state_LISTEN: tcp_state = 1;
pub const tcp_state_SYN_SENT: tcp_state = 2;
pub const tcp_state_SYN_RCVD: tcp_state = 3;
pub const tcp_state_ESTABLISHED: tcp_state = 4;
pub const tcp_state_FIN_WAIT_1: tcp_state = 5;
pub const tcp_state_FIN_WAIT_2: tcp_state = 6;
pub const tcp_state_CLOSE_WAIT: tcp_state = 7;
pub const tcp_state_CLOSING: tcp_state = 8;
pub const tcp_state_LAST_ACK: tcp_state = 9;
pub const tcp_state_TIME_WAIT: tcp_state = 10;
pub type tcp_state = ::std::os::raw::c_uint;
extern "C" {
    pub fn tcp_debug_state_str(s: tcp_state) -> *const ::std::os::raw::c_char;
}
pub type mem_size_t = size_t;
extern "C" {
    pub fn mem_init();
}
extern "C" {
    pub fn mem_trim(
        mem: *mut ::std::os::raw::c_void,
        size: mem_size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mem_malloc(size: mem_size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mem_calloc(count: mem_size_t, size: mem_size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mem_free(mem: *mut ::std::os::raw::c_void);
}
#[doc = " No error, everything OK."]
pub const err_enum_t_ERR_OK: err_enum_t = 0;
#[doc = " Out of memory error."]
pub const err_enum_t_ERR_MEM: err_enum_t = -1;
#[doc = " Buffer error."]
pub const err_enum_t_ERR_BUF: err_enum_t = -2;
#[doc = " Timeout."]
pub const err_enum_t_ERR_TIMEOUT: err_enum_t = -3;
#[doc = " Routing problem."]
pub const err_enum_t_ERR_RTE: err_enum_t = -4;
#[doc = " Operation in progress"]
pub const err_enum_t_ERR_INPROGRESS: err_enum_t = -5;
#[doc = " Illegal value."]
pub const err_enum_t_ERR_VAL: err_enum_t = -6;
#[doc = " Operation would block."]
pub const err_enum_t_ERR_WOULDBLOCK: err_enum_t = -7;
#[doc = " Address in use."]
pub const err_enum_t_ERR_USE: err_enum_t = -8;
#[doc = " Already connecting."]
pub const err_enum_t_ERR_ALREADY: err_enum_t = -9;
#[doc = " Conn already established."]
pub const err_enum_t_ERR_ISCONN: err_enum_t = -10;
#[doc = " Not connected."]
pub const err_enum_t_ERR_CONN: err_enum_t = -11;
#[doc = " Low-level netif error"]
pub const err_enum_t_ERR_IF: err_enum_t = -12;
#[doc = " Connection aborted."]
pub const err_enum_t_ERR_ABRT: err_enum_t = -13;
#[doc = " Connection reset."]
pub const err_enum_t_ERR_RST: err_enum_t = -14;
#[doc = " Connection closed."]
pub const err_enum_t_ERR_CLSD: err_enum_t = -15;
#[doc = " Illegal argument."]
pub const err_enum_t_ERR_ARG: err_enum_t = -16;
#[doc = " Definitions for error constants."]
pub type err_enum_t = ::std::os::raw::c_int;
pub type err_t = s8_t;
#[doc = " Includes spare room for transport layer header, e.g. UDP header."]
#[doc = " Use this if you intend to pass the pbuf to functions like udp_send()."]
pub const pbuf_layer_PBUF_TRANSPORT: pbuf_layer = 74;
#[doc = " Includes spare room for IP header."]
#[doc = " Use this if you intend to pass the pbuf to functions like raw_send()."]
pub const pbuf_layer_PBUF_IP: pbuf_layer = 54;
#[doc = " Includes spare room for link layer header (ethernet header)."]
#[doc = " Use this if you intend to pass the pbuf to functions like ethernet_output()."]
#[doc = " @see PBUF_LINK_HLEN"]
pub const pbuf_layer_PBUF_LINK: pbuf_layer = 14;
#[doc = " Includes spare room for additional encapsulation header before ethernet"]
#[doc = " headers (e.g. 802.11)."]
#[doc = " Use this if you intend to pass the pbuf to functions like netif->linkoutput()."]
#[doc = " @see PBUF_LINK_ENCAPSULATION_HLEN"]
pub const pbuf_layer_PBUF_RAW_TX: pbuf_layer = 0;
#[doc = " Use this for input packets in a netif driver when calling netif->input()"]
#[doc = " in the most common case - ethernet-layer netif driver."]
pub const pbuf_layer_PBUF_RAW: pbuf_layer = 0;
#[doc = " @ingroup pbuf"]
#[doc = " Enumeration of pbuf layers"]
pub type pbuf_layer = ::std::os::raw::c_uint;
#[doc = " pbuf data is stored in RAM, used for TX mostly, struct pbuf and its payload"]
#[doc = "are allocated in one piece of contiguous memory (so the first payload byte"]
#[doc = "can be calculated from struct pbuf)."]
#[doc = "pbuf_alloc() allocates PBUF_RAM pbufs as unchained pbufs (although that might"]
#[doc = "change in future versions)."]
#[doc = "This should be used for all OUTGOING packets (TX)."]
pub const pbuf_type_PBUF_RAM: pbuf_type = 640;
#[doc = " pbuf data is stored in ROM, i.e. struct pbuf and its payload are located in"]
#[doc = "totally different memory areas. Since it points to ROM, payload does not"]
#[doc = "have to be copied when queued for transmission."]
pub const pbuf_type_PBUF_ROM: pbuf_type = 1;
#[doc = " pbuf comes from the pbuf pool. Much like PBUF_ROM but payload might change"]
#[doc = "so it has to be duplicated when queued before transmitting, depending on"]
#[doc = "who has a 'ref' to it."]
pub const pbuf_type_PBUF_REF: pbuf_type = 65;
#[doc = " pbuf payload refers to RAM. This one comes from a pool and should be used"]
#[doc = "for RX. Payload can be chained (scatter-gather RX) but like PBUF_RAM, struct"]
#[doc = "pbuf and its payload are allocated in one piece of contiguous memory (so"]
#[doc = "the first payload byte can be calculated from struct pbuf)."]
#[doc = "Don't use this for TX, if the pool becomes empty e.g. because of TCP queuing,"]
#[doc = "you are unable to receive TCP acks!"]
pub const pbuf_type_PBUF_POOL: pbuf_type = 386;
#[doc = " @ingroup pbuf"]
#[doc = " Enumeration of pbuf types"]
pub type pbuf_type = ::std::os::raw::c_uint;
#[doc = " Main packet buffer struct"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pbuf {
    #[doc = " next pbuf in singly linked pbuf chain"]
    pub next: *mut pbuf,
    #[doc = " pointer to the actual data in the buffer"]
    pub payload: *mut ::std::os::raw::c_void,
    #[doc = " total length of this buffer and all next buffers in chain"]
    #[doc = " belonging to the same packet."]
    #[doc = ""]
    #[doc = " For non-queue packet chains this is the invariant:"]
    #[doc = " p->tot_len == p->len + (p->next? p->next->tot_len: 0)"]
    pub tot_len: u16_t,
    #[doc = " length of this buffer"]
    pub len: u16_t,
    #[doc = " a bit field indicating pbuf type and allocation sources"]
    #[doc = "(see PBUF_TYPE_FLAG_*, PBUF_ALLOC_FLAG_* and PBUF_TYPE_ALLOC_SRC_MASK)"]
    pub type_internal: u8_t,
    #[doc = " misc flags"]
    pub flags: u8_t,
    #[doc = " the reference count always equals the number of pointers"]
    #[doc = " that refer to this pbuf. This can be pointers from an application,"]
    #[doc = " the stack itself, or pbuf->next pointers from a chain."]
    pub ref_: u8_t,
    #[doc = " For incoming packets, this contains the input netif's index"]
    pub if_idx: u8_t,
}
#[test]
fn bindgen_test_layout_pbuf() {
    assert_eq!(
        ::std::mem::size_of::<pbuf>(),
        24usize,
        concat!("Size of: ", stringify!(pbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<pbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(pbuf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pbuf>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pbuf),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pbuf>())).payload as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pbuf),
            "::",
            stringify!(payload)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pbuf>())).tot_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pbuf),
            "::",
            stringify!(tot_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pbuf>())).len as *const _ as usize },
        18usize,
        concat!("Offset of field: ", stringify!(pbuf), "::", stringify!(len))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pbuf>())).type_internal as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pbuf),
            "::",
            stringify!(type_internal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pbuf>())).flags as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(pbuf),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pbuf>())).ref_ as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(pbuf),
            "::",
            stringify!(ref_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pbuf>())).if_idx as *const _ as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(pbuf),
            "::",
            stringify!(if_idx)
        )
    );
}
#[doc = " Helper struct for const-correctness only."]
#[doc = " The only meaning of this one is to provide a const payload pointer"]
#[doc = " for PBUF_ROM type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pbuf_rom {
    #[doc = " next pbuf in singly linked pbuf chain"]
    pub next: *mut pbuf,
    #[doc = " pointer to the actual data in the buffer"]
    pub payload: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_pbuf_rom() {
    assert_eq!(
        ::std::mem::size_of::<pbuf_rom>(),
        16usize,
        concat!("Size of: ", stringify!(pbuf_rom))
    );
    assert_eq!(
        ::std::mem::align_of::<pbuf_rom>(),
        8usize,
        concat!("Alignment of ", stringify!(pbuf_rom))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pbuf_rom>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pbuf_rom),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pbuf_rom>())).payload as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pbuf_rom),
            "::",
            stringify!(payload)
        )
    );
}
#[doc = " Prototype for a function to free a custom pbuf"]
pub type pbuf_free_custom_fn = ::std::option::Option<unsafe extern "C" fn(p: *mut pbuf)>;
#[doc = " A custom pbuf: like a pbuf, but following a function pointer to free it."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pbuf_custom {
    #[doc = " The actual pbuf"]
    pub pbuf: pbuf,
    #[doc = " This function is called when pbuf_free deallocates this pbuf(_custom)"]
    pub custom_free_function: pbuf_free_custom_fn,
}
#[test]
fn bindgen_test_layout_pbuf_custom() {
    assert_eq!(
        ::std::mem::size_of::<pbuf_custom>(),
        32usize,
        concat!("Size of: ", stringify!(pbuf_custom))
    );
    assert_eq!(
        ::std::mem::align_of::<pbuf_custom>(),
        8usize,
        concat!("Alignment of ", stringify!(pbuf_custom))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pbuf_custom>())).pbuf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pbuf_custom),
            "::",
            stringify!(pbuf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pbuf_custom>())).custom_free_function as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pbuf_custom),
            "::",
            stringify!(custom_free_function)
        )
    );
}
extern "C" {
    pub static mut pbuf_free_ooseq_pending: u8_t;
}
extern "C" {
    pub fn pbuf_free_ooseq();
}
extern "C" {
    pub fn pbuf_alloc(l: pbuf_layer, length: u16_t, type_: pbuf_type) -> *mut pbuf;
}
extern "C" {
    pub fn pbuf_alloc_reference(
        payload: *mut ::std::os::raw::c_void,
        length: u16_t,
        type_: pbuf_type,
    ) -> *mut pbuf;
}
extern "C" {
    pub fn pbuf_alloced_custom(
        l: pbuf_layer,
        length: u16_t,
        type_: pbuf_type,
        p: *mut pbuf_custom,
        payload_mem: *mut ::std::os::raw::c_void,
        payload_mem_len: u16_t,
    ) -> *mut pbuf;
}
extern "C" {
    pub fn pbuf_realloc(p: *mut pbuf, size: u16_t);
}
extern "C" {
    pub fn pbuf_header(p: *mut pbuf, header_size: s16_t) -> u8_t;
}
extern "C" {
    pub fn pbuf_header_force(p: *mut pbuf, header_size: s16_t) -> u8_t;
}
extern "C" {
    pub fn pbuf_add_header(p: *mut pbuf, header_size_increment: size_t) -> u8_t;
}
extern "C" {
    pub fn pbuf_add_header_force(p: *mut pbuf, header_size_increment: size_t) -> u8_t;
}
extern "C" {
    pub fn pbuf_remove_header(p: *mut pbuf, header_size: size_t) -> u8_t;
}
extern "C" {
    pub fn pbuf_free_header(q: *mut pbuf, size: u16_t) -> *mut pbuf;
}
extern "C" {
    pub fn pbuf_ref(p: *mut pbuf);
}
extern "C" {
    pub fn pbuf_free(p: *mut pbuf) -> u8_t;
}
extern "C" {
    pub fn pbuf_clen(p: *const pbuf) -> u16_t;
}
extern "C" {
    pub fn pbuf_cat(head: *mut pbuf, tail: *mut pbuf);
}
extern "C" {
    pub fn pbuf_chain(head: *mut pbuf, tail: *mut pbuf);
}
extern "C" {
    pub fn pbuf_dechain(p: *mut pbuf) -> *mut pbuf;
}
extern "C" {
    pub fn pbuf_copy(p_to: *mut pbuf, p_from: *const pbuf) -> err_t;
}
extern "C" {
    pub fn pbuf_copy_partial_pbuf(
        p_to: *mut pbuf,
        p_from: *const pbuf,
        copy_len: u16_t,
        offset: u16_t,
    ) -> err_t;
}
extern "C" {
    pub fn pbuf_copy_partial(
        p: *const pbuf,
        dataptr: *mut ::std::os::raw::c_void,
        len: u16_t,
        offset: u16_t,
    ) -> u16_t;
}
extern "C" {
    pub fn pbuf_get_contiguous(
        p: *const pbuf,
        buffer: *mut ::std::os::raw::c_void,
        bufsize: size_t,
        len: u16_t,
        offset: u16_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pbuf_take(buf: *mut pbuf, dataptr: *const ::std::os::raw::c_void, len: u16_t) -> err_t;
}
extern "C" {
    pub fn pbuf_take_at(
        buf: *mut pbuf,
        dataptr: *const ::std::os::raw::c_void,
        len: u16_t,
        offset: u16_t,
    ) -> err_t;
}
extern "C" {
    pub fn pbuf_skip(in_: *mut pbuf, in_offset: u16_t, out_offset: *mut u16_t) -> *mut pbuf;
}
extern "C" {
    pub fn pbuf_coalesce(p: *mut pbuf, layer: pbuf_layer) -> *mut pbuf;
}
extern "C" {
    pub fn pbuf_clone(l: pbuf_layer, type_: pbuf_type, p: *mut pbuf) -> *mut pbuf;
}
extern "C" {
    pub fn pbuf_get_at(p: *const pbuf, offset: u16_t) -> u8_t;
}
extern "C" {
    pub fn pbuf_try_get_at(p: *const pbuf, offset: u16_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbuf_put_at(p: *mut pbuf, offset: u16_t, data: u8_t);
}
extern "C" {
    pub fn pbuf_memcmp(
        p: *const pbuf,
        offset: u16_t,
        s2: *const ::std::os::raw::c_void,
        n: u16_t,
    ) -> u16_t;
}
extern "C" {
    pub fn pbuf_memfind(
        p: *const pbuf,
        mem: *const ::std::os::raw::c_void,
        mem_len: u16_t,
        start_offset: u16_t,
    ) -> u16_t;
}
extern "C" {
    pub fn pbuf_strstr(p: *const pbuf, substr: *const ::std::os::raw::c_char) -> u16_t;
}
extern "C" {
    pub fn lwip_htons(x: u16_t) -> u16_t;
}
extern "C" {
    pub fn lwip_htonl(x: u32_t) -> u32_t;
}
extern "C" {
    pub fn lwip_itoa(
        result: *mut ::std::os::raw::c_char,
        bufsize: size_t,
        number: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn lwip_strnicmp(
        str1: *const ::std::os::raw::c_char,
        str2: *const ::std::os::raw::c_char,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lwip_stricmp(
        str1: *const ::std::os::raw::c_char,
        str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lwip_strnstr(
        buffer: *const ::std::os::raw::c_char,
        token: *const ::std::os::raw::c_char,
        n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
#[doc = " This is the aligned version of ip4_addr_t,"]
#[doc = "used as local variable, on the stack, etc."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip4_addr {
    pub addr: u32_t,
}
#[test]
fn bindgen_test_layout_ip4_addr() {
    assert_eq!(
        ::std::mem::size_of::<ip4_addr>(),
        4usize,
        concat!("Size of: ", stringify!(ip4_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<ip4_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(ip4_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip4_addr>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip4_addr),
            "::",
            stringify!(addr)
        )
    );
}
#[doc = " This is the aligned version of ip4_addr_t,"]
#[doc = "used as local variable, on the stack, etc."]
pub type ip4_addr_t = ip4_addr;
extern "C" {
    pub fn ip4_addr_isbroadcast_u32(addr: u32_t, netif: *const netif) -> u8_t;
}
extern "C" {
    pub fn ip4_addr_netmask_valid(netmask: u32_t) -> u8_t;
}
extern "C" {
    pub fn ipaddr_addr(cp: *const ::std::os::raw::c_char) -> u32_t;
}
extern "C" {
    pub fn ip4addr_aton(
        cp: *const ::std::os::raw::c_char,
        addr: *mut ip4_addr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns ptr to static buffer; not reentrant!"]
    pub fn ip4addr_ntoa(addr: *const ip4_addr_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ip4addr_ntoa_r(
        addr: *const ip4_addr_t,
        buf: *mut ::std::os::raw::c_char,
        buflen: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
#[doc = " Unknown"]
pub const lwip_ipv6_scope_type_IP6_UNKNOWN: lwip_ipv6_scope_type = 0;
#[doc = " Unicast"]
pub const lwip_ipv6_scope_type_IP6_UNICAST: lwip_ipv6_scope_type = 1;
#[doc = " Multicast"]
pub const lwip_ipv6_scope_type_IP6_MULTICAST: lwip_ipv6_scope_type = 2;
#[doc = " Symbolic constants for the 'type' parameters in some of the macros."]
#[doc = " These exist for efficiency only, allowing the macros to avoid certain tests"]
#[doc = " when the address is known not to be of a certain type. Dead code elimination"]
#[doc = " will do the rest. IP6_MULTICAST is supported but currently not optimized."]
#[doc = " @see ip6_addr_has_scope, ip6_addr_assign_zone, ip6_addr_lacks_zone."]
pub type lwip_ipv6_scope_type = ::std::os::raw::c_uint;
#[doc = " This is the aligned version of ip6_addr_t,"]
#[doc = "used as local variable, on the stack, etc."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_addr {
    pub addr: [u32_t; 4usize],
    pub zone: u8_t,
}
#[test]
fn bindgen_test_layout_ip6_addr() {
    assert_eq!(
        ::std::mem::size_of::<ip6_addr>(),
        20usize,
        concat!("Size of: ", stringify!(ip6_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<ip6_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(ip6_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip6_addr>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_addr),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip6_addr>())).zone as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_addr),
            "::",
            stringify!(zone)
        )
    );
}
#[doc = " This is the aligned version of ip6_addr_t,"]
#[doc = "used as local variable, on the stack, etc."]
pub type ip6_addr_t = ip6_addr;
extern "C" {
    pub fn ip6addr_aton(
        cp: *const ::std::os::raw::c_char,
        addr: *mut ip6_addr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns ptr to static buffer; not reentrant!"]
    pub fn ip6addr_ntoa(addr: *const ip6_addr_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ip6addr_ntoa_r(
        addr: *const ip6_addr_t,
        buf: *mut ::std::os::raw::c_char,
        buflen: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
#[doc = " IPv4"]
pub const lwip_ip_addr_type_IPADDR_TYPE_V4: lwip_ip_addr_type = 0;
#[doc = " IPv6"]
pub const lwip_ip_addr_type_IPADDR_TYPE_V6: lwip_ip_addr_type = 6;
#[doc = " IPv4+IPv6 (\"dual-stack\")"]
pub const lwip_ip_addr_type_IPADDR_TYPE_ANY: lwip_ip_addr_type = 46;
#[doc = " @ingroup ipaddr"]
#[doc = " IP address types for use in ip_addr_t.type member."]
#[doc = " @see tcp_new_ip_type(), udp_new_ip_type(), raw_new_ip_type()."]
pub type lwip_ip_addr_type = ::std::os::raw::c_uint;
#[doc = " @ingroup ipaddr"]
#[doc = " A union struct for both IP version's addresses."]
#[doc = " ATTENTION: watch out for its size when adding IPv6 address scope!"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_addr {
    pub u_addr: ip_addr__bindgen_ty_1,
    #[doc = " @ref lwip_ip_addr_type"]
    pub type_: u8_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ip_addr__bindgen_ty_1 {
    pub ip6: ip6_addr_t,
    pub ip4: ip4_addr_t,
}
#[test]
fn bindgen_test_layout_ip_addr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ip_addr__bindgen_ty_1>(),
        20usize,
        concat!("Size of: ", stringify!(ip_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_addr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_addr__bindgen_ty_1>())).ip6 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_addr__bindgen_ty_1),
            "::",
            stringify!(ip6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_addr__bindgen_ty_1>())).ip4 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_addr__bindgen_ty_1),
            "::",
            stringify!(ip4)
        )
    );
}
#[test]
fn bindgen_test_layout_ip_addr() {
    assert_eq!(
        ::std::mem::size_of::<ip_addr>(),
        24usize,
        concat!("Size of: ", stringify!(ip_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_addr>())).u_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_addr),
            "::",
            stringify!(u_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_addr>())).type_ as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_addr),
            "::",
            stringify!(type_)
        )
    );
}
#[doc = " @ingroup ipaddr"]
#[doc = " A union struct for both IP version's addresses."]
#[doc = " ATTENTION: watch out for its size when adding IPv6 address scope!"]
pub type ip_addr_t = ip_addr;
extern "C" {
    pub static ip_addr_any_type: ip_addr_t;
}
extern "C" {
    pub fn ipaddr_ntoa(addr: *const ip_addr_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ipaddr_ntoa_r(
        addr: *const ip_addr_t,
        buf: *mut ::std::os::raw::c_char,
        buflen: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ipaddr_aton(
        cp: *const ::std::os::raw::c_char,
        addr: *mut ip_addr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static ip_addr_any: ip_addr_t;
}
extern "C" {
    pub static ip_addr_broadcast: ip_addr_t;
}
extern "C" {
    pub static ip6_addr_any: ip_addr_t;
}
pub const memp_t_MEMP_TCP_PCB: memp_t = 0;
pub const memp_t_MEMP_TCP_PCB_LISTEN: memp_t = 1;
pub const memp_t_MEMP_TCP_SEG: memp_t = 2;
pub const memp_t_MEMP_REASSDATA: memp_t = 3;
pub const memp_t_MEMP_FRAG_PBUF: memp_t = 4;
pub const memp_t_MEMP_ND6_QUEUE: memp_t = 5;
pub const memp_t_MEMP_IP6_REASSDATA: memp_t = 6;
pub const memp_t_MEMP_PBUF: memp_t = 7;
pub const memp_t_MEMP_PBUF_POOL: memp_t = 8;
pub const memp_t_MEMP_MAX: memp_t = 9;
#[doc = " Create the list of all memory pools managed by memp. MEMP_MAX represents a NULL pool at the end"]
pub type memp_t = ::std::os::raw::c_uint;
#[doc = " Memory pool descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct memp_desc {
    #[doc = " Element size"]
    pub size: u16_t,
}
#[test]
fn bindgen_test_layout_memp_desc() {
    assert_eq!(
        ::std::mem::size_of::<memp_desc>(),
        2usize,
        concat!("Size of: ", stringify!(memp_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<memp_desc>(),
        2usize,
        concat!("Alignment of ", stringify!(memp_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<memp_desc>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(memp_desc),
            "::",
            stringify!(size)
        )
    );
}
extern "C" {
    pub fn memp_init_pool(desc: *const memp_desc);
}
extern "C" {
    pub fn memp_malloc_pool(desc: *const memp_desc) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memp_free_pool(desc: *const memp_desc, mem: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub static memp_pools: [*const memp_desc; 9usize];
}
extern "C" {
    pub fn memp_init();
}
extern "C" {
    pub fn memp_malloc(type_: memp_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memp_free(type_: memp_t, mem: *mut ::std::os::raw::c_void);
}
#[doc = " Protocol related stats"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stats_proto {
    pub xmit: u16_t,
    pub recv: u16_t,
    pub fw: u16_t,
    pub drop: u16_t,
    pub chkerr: u16_t,
    pub lenerr: u16_t,
    pub memerr: u16_t,
    pub rterr: u16_t,
    pub proterr: u16_t,
    pub opterr: u16_t,
    pub err: u16_t,
    pub cachehit: u16_t,
}
#[test]
fn bindgen_test_layout_stats_proto() {
    assert_eq!(
        ::std::mem::size_of::<stats_proto>(),
        24usize,
        concat!("Size of: ", stringify!(stats_proto))
    );
    assert_eq!(
        ::std::mem::align_of::<stats_proto>(),
        2usize,
        concat!("Alignment of ", stringify!(stats_proto))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_proto>())).xmit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_proto),
            "::",
            stringify!(xmit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_proto>())).recv as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_proto),
            "::",
            stringify!(recv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_proto>())).fw as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_proto),
            "::",
            stringify!(fw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_proto>())).drop as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_proto),
            "::",
            stringify!(drop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_proto>())).chkerr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_proto),
            "::",
            stringify!(chkerr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_proto>())).lenerr as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_proto),
            "::",
            stringify!(lenerr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_proto>())).memerr as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_proto),
            "::",
            stringify!(memerr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_proto>())).rterr as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_proto),
            "::",
            stringify!(rterr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_proto>())).proterr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_proto),
            "::",
            stringify!(proterr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_proto>())).opterr as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_proto),
            "::",
            stringify!(opterr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_proto>())).err as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_proto),
            "::",
            stringify!(err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_proto>())).cachehit as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_proto),
            "::",
            stringify!(cachehit)
        )
    );
}
#[doc = " IGMP stats"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stats_igmp {
    pub xmit: u16_t,
    pub recv: u16_t,
    pub drop: u16_t,
    pub chkerr: u16_t,
    pub lenerr: u16_t,
    pub memerr: u16_t,
    pub proterr: u16_t,
    pub rx_v1: u16_t,
    pub rx_group: u16_t,
    pub rx_general: u16_t,
    pub rx_report: u16_t,
    pub tx_join: u16_t,
    pub tx_leave: u16_t,
    pub tx_report: u16_t,
}
#[test]
fn bindgen_test_layout_stats_igmp() {
    assert_eq!(
        ::std::mem::size_of::<stats_igmp>(),
        28usize,
        concat!("Size of: ", stringify!(stats_igmp))
    );
    assert_eq!(
        ::std::mem::align_of::<stats_igmp>(),
        2usize,
        concat!("Alignment of ", stringify!(stats_igmp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_igmp>())).xmit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_igmp),
            "::",
            stringify!(xmit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_igmp>())).recv as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_igmp),
            "::",
            stringify!(recv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_igmp>())).drop as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_igmp),
            "::",
            stringify!(drop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_igmp>())).chkerr as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_igmp),
            "::",
            stringify!(chkerr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_igmp>())).lenerr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_igmp),
            "::",
            stringify!(lenerr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_igmp>())).memerr as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_igmp),
            "::",
            stringify!(memerr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_igmp>())).proterr as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_igmp),
            "::",
            stringify!(proterr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_igmp>())).rx_v1 as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_igmp),
            "::",
            stringify!(rx_v1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_igmp>())).rx_group as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_igmp),
            "::",
            stringify!(rx_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_igmp>())).rx_general as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_igmp),
            "::",
            stringify!(rx_general)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_igmp>())).rx_report as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_igmp),
            "::",
            stringify!(rx_report)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_igmp>())).tx_join as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_igmp),
            "::",
            stringify!(tx_join)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_igmp>())).tx_leave as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_igmp),
            "::",
            stringify!(tx_leave)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_igmp>())).tx_report as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_igmp),
            "::",
            stringify!(tx_report)
        )
    );
}
#[doc = " Memory stats"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stats_mem {
    pub err: u16_t,
    pub avail: mem_size_t,
    pub used: mem_size_t,
    pub max: mem_size_t,
    pub illegal: u16_t,
}
#[test]
fn bindgen_test_layout_stats_mem() {
    assert_eq!(
        ::std::mem::size_of::<stats_mem>(),
        40usize,
        concat!("Size of: ", stringify!(stats_mem))
    );
    assert_eq!(
        ::std::mem::align_of::<stats_mem>(),
        8usize,
        concat!("Alignment of ", stringify!(stats_mem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mem>())).err as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mem),
            "::",
            stringify!(err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mem>())).avail as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mem),
            "::",
            stringify!(avail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mem>())).used as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mem),
            "::",
            stringify!(used)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mem>())).max as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mem),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mem>())).illegal as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mem),
            "::",
            stringify!(illegal)
        )
    );
}
#[doc = " System element stats"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stats_syselem {
    pub used: u16_t,
    pub max: u16_t,
    pub err: u16_t,
}
#[test]
fn bindgen_test_layout_stats_syselem() {
    assert_eq!(
        ::std::mem::size_of::<stats_syselem>(),
        6usize,
        concat!("Size of: ", stringify!(stats_syselem))
    );
    assert_eq!(
        ::std::mem::align_of::<stats_syselem>(),
        2usize,
        concat!("Alignment of ", stringify!(stats_syselem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_syselem>())).used as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_syselem),
            "::",
            stringify!(used)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_syselem>())).max as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_syselem),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_syselem>())).err as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_syselem),
            "::",
            stringify!(err)
        )
    );
}
#[doc = " System stats"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stats_sys {
    pub sem: stats_syselem,
    pub mutex: stats_syselem,
    pub mbox: stats_syselem,
}
#[test]
fn bindgen_test_layout_stats_sys() {
    assert_eq!(
        ::std::mem::size_of::<stats_sys>(),
        18usize,
        concat!("Size of: ", stringify!(stats_sys))
    );
    assert_eq!(
        ::std::mem::align_of::<stats_sys>(),
        2usize,
        concat!("Alignment of ", stringify!(stats_sys))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_sys>())).sem as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_sys),
            "::",
            stringify!(sem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_sys>())).mutex as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_sys),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_sys>())).mbox as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_sys),
            "::",
            stringify!(mbox)
        )
    );
}
#[doc = " SNMP MIB2 stats"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stats_mib2 {
    pub ipinhdrerrors: u32_t,
    pub ipinaddrerrors: u32_t,
    pub ipinunknownprotos: u32_t,
    pub ipindiscards: u32_t,
    pub ipindelivers: u32_t,
    pub ipoutrequests: u32_t,
    pub ipoutdiscards: u32_t,
    pub ipoutnoroutes: u32_t,
    pub ipreasmoks: u32_t,
    pub ipreasmfails: u32_t,
    pub ipfragoks: u32_t,
    pub ipfragfails: u32_t,
    pub ipfragcreates: u32_t,
    pub ipreasmreqds: u32_t,
    pub ipforwdatagrams: u32_t,
    pub ipinreceives: u32_t,
    pub tcpactiveopens: u32_t,
    pub tcppassiveopens: u32_t,
    pub tcpattemptfails: u32_t,
    pub tcpestabresets: u32_t,
    pub tcpoutsegs: u32_t,
    pub tcpretranssegs: u32_t,
    pub tcpinsegs: u32_t,
    pub tcpinerrs: u32_t,
    pub tcpoutrsts: u32_t,
    pub udpindatagrams: u32_t,
    pub udpnoports: u32_t,
    pub udpinerrors: u32_t,
    pub udpoutdatagrams: u32_t,
    pub icmpinmsgs: u32_t,
    pub icmpinerrors: u32_t,
    pub icmpindestunreachs: u32_t,
    pub icmpintimeexcds: u32_t,
    pub icmpinparmprobs: u32_t,
    pub icmpinsrcquenchs: u32_t,
    pub icmpinredirects: u32_t,
    pub icmpinechos: u32_t,
    pub icmpinechoreps: u32_t,
    pub icmpintimestamps: u32_t,
    pub icmpintimestampreps: u32_t,
    pub icmpinaddrmasks: u32_t,
    pub icmpinaddrmaskreps: u32_t,
    pub icmpoutmsgs: u32_t,
    pub icmpouterrors: u32_t,
    pub icmpoutdestunreachs: u32_t,
    pub icmpouttimeexcds: u32_t,
    pub icmpoutechos: u32_t,
    pub icmpoutechoreps: u32_t,
}
#[test]
fn bindgen_test_layout_stats_mib2() {
    assert_eq!(
        ::std::mem::size_of::<stats_mib2>(),
        192usize,
        concat!("Size of: ", stringify!(stats_mib2))
    );
    assert_eq!(
        ::std::mem::align_of::<stats_mib2>(),
        4usize,
        concat!("Alignment of ", stringify!(stats_mib2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).ipinhdrerrors as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(ipinhdrerrors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).ipinaddrerrors as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(ipinaddrerrors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).ipinunknownprotos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(ipinunknownprotos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).ipindiscards as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(ipindiscards)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).ipindelivers as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(ipindelivers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).ipoutrequests as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(ipoutrequests)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).ipoutdiscards as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(ipoutdiscards)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).ipoutnoroutes as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(ipoutnoroutes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).ipreasmoks as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(ipreasmoks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).ipreasmfails as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(ipreasmfails)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).ipfragoks as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(ipfragoks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).ipfragfails as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(ipfragfails)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).ipfragcreates as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(ipfragcreates)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).ipreasmreqds as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(ipreasmreqds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).ipforwdatagrams as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(ipforwdatagrams)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).ipinreceives as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(ipinreceives)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).tcpactiveopens as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(tcpactiveopens)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).tcppassiveopens as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(tcppassiveopens)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).tcpattemptfails as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(tcpattemptfails)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).tcpestabresets as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(tcpestabresets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).tcpoutsegs as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(tcpoutsegs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).tcpretranssegs as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(tcpretranssegs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).tcpinsegs as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(tcpinsegs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).tcpinerrs as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(tcpinerrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).tcpoutrsts as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(tcpoutrsts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).udpindatagrams as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(udpindatagrams)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).udpnoports as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(udpnoports)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).udpinerrors as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(udpinerrors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).udpoutdatagrams as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(udpoutdatagrams)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).icmpinmsgs as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(icmpinmsgs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).icmpinerrors as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(icmpinerrors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).icmpindestunreachs as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(icmpindestunreachs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).icmpintimeexcds as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(icmpintimeexcds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).icmpinparmprobs as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(icmpinparmprobs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).icmpinsrcquenchs as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(icmpinsrcquenchs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).icmpinredirects as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(icmpinredirects)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).icmpinechos as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(icmpinechos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).icmpinechoreps as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(icmpinechoreps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).icmpintimestamps as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(icmpintimestamps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).icmpintimestampreps as *const _ as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(icmpintimestampreps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).icmpinaddrmasks as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(icmpinaddrmasks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).icmpinaddrmaskreps as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(icmpinaddrmaskreps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).icmpoutmsgs as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(icmpoutmsgs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).icmpouterrors as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(icmpouterrors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).icmpoutdestunreachs as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(icmpoutdestunreachs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).icmpouttimeexcds as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(icmpouttimeexcds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).icmpoutechos as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(icmpoutechos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_mib2>())).icmpoutechoreps as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(icmpoutechoreps)
        )
    );
}
#[doc = " @ingroup netif_mib2"]
#[doc = " SNMP MIB2 interface stats"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stats_mib2_netif_ctrs {
    #[doc = " The total number of octets received on the interface, including framing characters"]
    pub ifinoctets: u32_t,
    #[doc = " The number of packets, delivered by this sub-layer to a higher (sub-)layer, which were"]
    #[doc = " not addressed to a multicast or broadcast address at this sub-layer"]
    pub ifinucastpkts: u32_t,
    #[doc = " The number of packets, delivered by this sub-layer to a higher (sub-)layer, which were"]
    #[doc = " addressed to a multicast or broadcast address at this sub-layer"]
    pub ifinnucastpkts: u32_t,
    #[doc = " The number of inbound packets which were chosen to be discarded even though no errors had"]
    #[doc = " been detected to prevent their being deliverable to a higher-layer protocol. One possible"]
    #[doc = " reason for discarding such a packet could be to free up buffer space"]
    pub ifindiscards: u32_t,
    #[doc = " For packet-oriented interfaces, the number of inbound packets that contained errors"]
    #[doc = " preventing them from being deliverable to a higher-layer protocol.  For character-"]
    #[doc = " oriented or fixed-length interfaces, the number of inbound transmission units that"]
    #[doc = " contained errors preventing them from being deliverable to a higher-layer protocol."]
    pub ifinerrors: u32_t,
    #[doc = " For packet-oriented interfaces, the number of packets received via the interface which"]
    #[doc = " were discarded because of an unknown or unsupported protocol.  For character-oriented"]
    #[doc = " or fixed-length interfaces that support protocol multiplexing the number of transmission"]
    #[doc = " units received via the interface which were discarded because of an unknown or unsupported"]
    #[doc = " protocol. For any interface that does not support protocol multiplexing, this counter will"]
    #[doc = " always be 0"]
    pub ifinunknownprotos: u32_t,
    #[doc = " The total number of octets transmitted out of the interface, including framing characters."]
    pub ifoutoctets: u32_t,
    #[doc = " The total number of packets that higher-level protocols requested be transmitted, and"]
    #[doc = " which were not addressed to a multicast or broadcast address at this sub-layer, including"]
    #[doc = " those that were discarded or not sent."]
    pub ifoutucastpkts: u32_t,
    #[doc = " The total number of packets that higher-level protocols requested be transmitted, and which"]
    #[doc = " were addressed to a multicast or broadcast address at this sub-layer, including"]
    #[doc = " those that were discarded or not sent."]
    pub ifoutnucastpkts: u32_t,
    #[doc = " The number of outbound packets which were chosen to be discarded even though no errors had"]
    #[doc = " been detected to prevent their being transmitted.  One possible reason for discarding"]
    #[doc = " such a packet could be to free up buffer space."]
    pub ifoutdiscards: u32_t,
    #[doc = " For packet-oriented interfaces, the number of outbound packets that could not be transmitted"]
    #[doc = " because of errors. For character-oriented or fixed-length interfaces, the number of outbound"]
    #[doc = " transmission units that could not be transmitted because of errors."]
    pub ifouterrors: u32_t,
}
#[test]
fn bindgen_test_layout_stats_mib2_netif_ctrs() {
    assert_eq!(
        ::std::mem::size_of::<stats_mib2_netif_ctrs>(),
        44usize,
        concat!("Size of: ", stringify!(stats_mib2_netif_ctrs))
    );
    assert_eq!(
        ::std::mem::align_of::<stats_mib2_netif_ctrs>(),
        4usize,
        concat!("Alignment of ", stringify!(stats_mib2_netif_ctrs))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<stats_mib2_netif_ctrs>())).ifinoctets as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2_netif_ctrs),
            "::",
            stringify!(ifinoctets)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<stats_mib2_netif_ctrs>())).ifinucastpkts as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2_netif_ctrs),
            "::",
            stringify!(ifinucastpkts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<stats_mib2_netif_ctrs>())).ifinnucastpkts as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2_netif_ctrs),
            "::",
            stringify!(ifinnucastpkts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<stats_mib2_netif_ctrs>())).ifindiscards as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2_netif_ctrs),
            "::",
            stringify!(ifindiscards)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<stats_mib2_netif_ctrs>())).ifinerrors as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2_netif_ctrs),
            "::",
            stringify!(ifinerrors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<stats_mib2_netif_ctrs>())).ifinunknownprotos as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2_netif_ctrs),
            "::",
            stringify!(ifinunknownprotos)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<stats_mib2_netif_ctrs>())).ifoutoctets as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2_netif_ctrs),
            "::",
            stringify!(ifoutoctets)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<stats_mib2_netif_ctrs>())).ifoutucastpkts as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2_netif_ctrs),
            "::",
            stringify!(ifoutucastpkts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<stats_mib2_netif_ctrs>())).ifoutnucastpkts as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2_netif_ctrs),
            "::",
            stringify!(ifoutnucastpkts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<stats_mib2_netif_ctrs>())).ifoutdiscards as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2_netif_ctrs),
            "::",
            stringify!(ifoutdiscards)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<stats_mib2_netif_ctrs>())).ifouterrors as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2_netif_ctrs),
            "::",
            stringify!(ifouterrors)
        )
    );
}
#[doc = " lwIP stats container"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stats_ {
    #[doc = " Link level"]
    pub link: stats_proto,
    #[doc = " Fragmentation"]
    pub ip_frag: stats_proto,
    #[doc = " IP"]
    pub ip: stats_proto,
    #[doc = " ICMP"]
    pub icmp: stats_proto,
    #[doc = " TCP"]
    pub tcp: stats_proto,
    #[doc = " IPv6"]
    pub ip6: stats_proto,
    #[doc = " ICMP6"]
    pub icmp6: stats_proto,
    #[doc = " IPv6 fragmentation"]
    pub ip6_frag: stats_proto,
    #[doc = " Neighbor discovery"]
    pub nd6: stats_proto,
}
#[test]
fn bindgen_test_layout_stats_() {
    assert_eq!(
        ::std::mem::size_of::<stats_>(),
        216usize,
        concat!("Size of: ", stringify!(stats_))
    );
    assert_eq!(
        ::std::mem::align_of::<stats_>(),
        2usize,
        concat!("Alignment of ", stringify!(stats_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_>())).link as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_>())).ip_frag as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_),
            "::",
            stringify!(ip_frag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_>())).ip as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_>())).icmp as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_),
            "::",
            stringify!(icmp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_>())).tcp as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_),
            "::",
            stringify!(tcp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_>())).ip6 as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_),
            "::",
            stringify!(ip6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_>())).icmp6 as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_),
            "::",
            stringify!(icmp6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_>())).ip6_frag as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_),
            "::",
            stringify!(ip6_frag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stats_>())).nd6 as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_),
            "::",
            stringify!(nd6)
        )
    );
}
extern "C" {
    #[doc = " Global variable containing lwIP internal statistics. Add this to your debugger's watchlist."]
    pub static mut lwip_stats: stats_;
}
extern "C" {
    #[doc = " Init statistics"]
    pub fn stats_init();
}
pub const lwip_internal_netif_client_data_index_LWIP_NETIF_CLIENT_DATA_INDEX_MAX:
    lwip_internal_netif_client_data_index = 0;
#[doc = " @}"]
pub type lwip_internal_netif_client_data_index = ::std::os::raw::c_uint;
#[doc = " Delete a filter entry"]
pub const netif_mac_filter_action_NETIF_DEL_MAC_FILTER: netif_mac_filter_action = 0;
#[doc = " Add a filter entry"]
pub const netif_mac_filter_action_NETIF_ADD_MAC_FILTER: netif_mac_filter_action = 1;
#[doc = " MAC Filter Actions, these are passed to a netif's igmp_mac_filter or"]
#[doc = " mld_mac_filter callback function."]
pub type netif_mac_filter_action = ::std::os::raw::c_uint;
#[doc = " Function prototype for netif init functions. Set up flags and output/linkoutput"]
#[doc = " callback functions in this function."]
#[doc = ""]
#[doc = " @param netif The netif to initialize"]
pub type netif_init_fn = ::std::option::Option<unsafe extern "C" fn(netif: *mut netif) -> err_t>;
#[doc = " Function prototype for netif->input functions. This function is saved as 'input'"]
#[doc = " callback function in the netif struct. Call it when a packet has been received."]
#[doc = ""]
#[doc = " @param p The received packet, copied into a pbuf"]
#[doc = " @param inp The netif which received the packet"]
#[doc = " @return ERR_OK if the packet was handled"]
#[doc = "         != ERR_OK is the packet was NOT handled, in this case, the caller has"]
#[doc = "                   to free the pbuf"]
pub type netif_input_fn =
    ::std::option::Option<unsafe extern "C" fn(p: *mut pbuf, inp: *mut netif) -> err_t>;
#[doc = " Function prototype for netif->output functions. Called by lwIP when a packet"]
#[doc = " shall be sent. For ethernet netif, set this to 'etharp_output' and set"]
#[doc = " 'linkoutput'."]
#[doc = ""]
#[doc = " @param netif The netif which shall send a packet"]
#[doc = " @param p The packet to send (p->payload points to IP header)"]
#[doc = " @param ipaddr The IP address to which the packet shall be sent"]
pub type netif_output_fn = ::std::option::Option<
    unsafe extern "C" fn(netif: *mut netif, p: *mut pbuf, ipaddr: *const ip4_addr_t) -> err_t,
>;
#[doc = " Function prototype for netif->output_ip6 functions. Called by lwIP when a packet"]
#[doc = " shall be sent. For ethernet netif, set this to 'ethip6_output' and set"]
#[doc = " 'linkoutput'."]
#[doc = ""]
#[doc = " @param netif The netif which shall send a packet"]
#[doc = " @param p The packet to send (p->payload points to IP header)"]
#[doc = " @param ipaddr The IPv6 address to which the packet shall be sent"]
pub type netif_output_ip6_fn = ::std::option::Option<
    unsafe extern "C" fn(netif: *mut netif, p: *mut pbuf, ipaddr: *const ip6_addr_t) -> err_t,
>;
#[doc = " Function prototype for netif->linkoutput functions. Only used for ethernet"]
#[doc = " netifs. This function is called by ARP when a packet shall be sent."]
#[doc = ""]
#[doc = " @param netif The netif which shall send a packet"]
#[doc = " @param p The packet to send (raw ethernet packet)"]
pub type netif_linkoutput_fn =
    ::std::option::Option<unsafe extern "C" fn(netif: *mut netif, p: *mut pbuf) -> err_t>;
#[doc = " Function prototype for netif status- or link-callback functions."]
pub type netif_status_callback_fn = ::std::option::Option<unsafe extern "C" fn(netif: *mut netif)>;
pub type netif_addr_idx_t = u8_t;
#[doc = " Generic data structure used for all lwIP network interfaces."]
#[doc = "  The following fields should be filled in by the initialization"]
#[doc = "  function for the device driver: hwaddr_len, hwaddr[], mtu, flags"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netif {
    #[doc = " pointer to next in linked list"]
    pub next: *mut netif,
    #[doc = " IP address configuration in network byte order"]
    pub ip_addr: ip_addr_t,
    pub netmask: ip_addr_t,
    pub gw: ip_addr_t,
    #[doc = " Array of IPv6 addresses for this netif."]
    pub ip6_addr: [ip_addr_t; 3usize],
    #[doc = " The state of each IPv6 address (Tentative, Preferred, etc)."]
    #[doc = " @see ip6_addr.h"]
    pub ip6_addr_state: [u8_t; 3usize],
    #[doc = " This function is called by the network device driver"]
    #[doc = "  to pass a packet up the TCP/IP stack."]
    pub input: netif_input_fn,
    #[doc = " This function is called by the IP module when it wants"]
    #[doc = "  to send a packet on the interface. This function typically"]
    #[doc = "  first resolves the hardware address, then sends the packet."]
    #[doc = "  For ethernet physical layer, this is usually etharp_output()"]
    pub output: netif_output_fn,
    #[doc = " This function is called by ethernet_output() when it wants"]
    #[doc = "  to send a packet on the interface. This function outputs"]
    #[doc = "  the pbuf as-is on the link medium."]
    pub linkoutput: netif_linkoutput_fn,
    #[doc = " This function is called by the IPv6 module when it wants"]
    #[doc = "  to send a packet on the interface. This function typically"]
    #[doc = "  first resolves the hardware address, then sends the packet."]
    #[doc = "  For ethernet physical layer, this is usually ethip6_output()"]
    pub output_ip6: netif_output_ip6_fn,
    #[doc = " This field can be set by the device driver and could point"]
    #[doc = "  to state information for the device."]
    pub state: *mut ::std::os::raw::c_void,
    #[doc = " maximum transfer unit (in bytes)"]
    pub mtu: u16_t,
    #[doc = " maximum transfer unit (in bytes), updated by RA"]
    pub mtu6: u16_t,
    #[doc = " link level hardware address of this interface"]
    pub hwaddr: [u8_t; 6usize],
    #[doc = " number of bytes used in hwaddr"]
    pub hwaddr_len: u8_t,
    #[doc = " flags (@see @ref netif_flags)"]
    pub flags: u8_t,
    #[doc = " descriptive abbreviation"]
    pub name: [::std::os::raw::c_char; 2usize],
    #[doc = " number of this interface. Used for @ref if_api and @ref netifapi_netif,"]
    #[doc = " as well as for IPv6 zones"]
    pub num: u8_t,
    #[doc = " Number of Router Solicitation messages that remain to be sent."]
    pub rs_count: u8_t,
}
#[test]
fn bindgen_test_layout_netif() {
    assert_eq!(
        ::std::mem::size_of::<netif>(),
        216usize,
        concat!("Size of: ", stringify!(netif))
    );
    assert_eq!(
        ::std::mem::align_of::<netif>(),
        8usize,
        concat!("Alignment of ", stringify!(netif))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<netif>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<netif>())).ip_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(ip_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<netif>())).netmask as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(netmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<netif>())).gw as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(netif), "::", stringify!(gw))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<netif>())).ip6_addr as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(ip6_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<netif>())).ip6_addr_state as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(ip6_addr_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<netif>())).input as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<netif>())).output as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(output)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<netif>())).linkoutput as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(linkoutput)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<netif>())).output_ip6 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(output_ip6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<netif>())).state as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<netif>())).mtu as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<netif>())).mtu6 as *const _ as usize },
        202usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(mtu6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<netif>())).hwaddr as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(hwaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<netif>())).hwaddr_len as *const _ as usize },
        210usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(hwaddr_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<netif>())).flags as *const _ as usize },
        211usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<netif>())).name as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<netif>())).num as *const _ as usize },
        214usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<netif>())).rs_count as *const _ as usize },
        215usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(rs_count)
        )
    );
}
extern "C" {
    #[doc = " The list of network interfaces."]
    pub static mut netif_list: *mut netif;
}
extern "C" {
    #[doc = " The default network interface."]
    pub static mut netif_default: *mut netif;
}
extern "C" {
    pub fn netif_init();
}
extern "C" {
    pub fn netif_add_noaddr(
        netif: *mut netif,
        state: *mut ::std::os::raw::c_void,
        init: netif_init_fn,
        input: netif_input_fn,
    ) -> *mut netif;
}
extern "C" {
    pub fn netif_add(
        netif: *mut netif,
        ipaddr: *const ip4_addr_t,
        netmask: *const ip4_addr_t,
        gw: *const ip4_addr_t,
        state: *mut ::std::os::raw::c_void,
        init: netif_init_fn,
        input: netif_input_fn,
    ) -> *mut netif;
}
extern "C" {
    pub fn netif_set_addr(
        netif: *mut netif,
        ipaddr: *const ip4_addr_t,
        netmask: *const ip4_addr_t,
        gw: *const ip4_addr_t,
    );
}
extern "C" {
    pub fn netif_remove(netif: *mut netif);
}
extern "C" {
    pub fn netif_find(name: *const ::std::os::raw::c_char) -> *mut netif;
}
extern "C" {
    pub fn netif_set_default(netif: *mut netif);
}
extern "C" {
    pub fn netif_set_ipaddr(netif: *mut netif, ipaddr: *const ip4_addr_t);
}
extern "C" {
    pub fn netif_set_netmask(netif: *mut netif, netmask: *const ip4_addr_t);
}
extern "C" {
    pub fn netif_set_gw(netif: *mut netif, gw: *const ip4_addr_t);
}
extern "C" {
    pub fn netif_set_up(netif: *mut netif);
}
extern "C" {
    pub fn netif_set_down(netif: *mut netif);
}
extern "C" {
    pub fn netif_set_link_up(netif: *mut netif);
}
extern "C" {
    pub fn netif_set_link_down(netif: *mut netif);
}
extern "C" {
    pub fn netif_input(p: *mut pbuf, inp: *mut netif) -> err_t;
}
extern "C" {
    pub fn netif_ip6_addr_set(netif: *mut netif, addr_idx: s8_t, addr6: *const ip6_addr_t);
}
extern "C" {
    pub fn netif_ip6_addr_set_parts(
        netif: *mut netif,
        addr_idx: s8_t,
        i0: u32_t,
        i1: u32_t,
        i2: u32_t,
        i3: u32_t,
    );
}
extern "C" {
    pub fn netif_ip6_addr_set_state(netif: *mut netif, addr_idx: s8_t, state: u8_t);
}
extern "C" {
    pub fn netif_get_ip6_addr_match(netif: *mut netif, ip6addr: *const ip6_addr_t) -> s8_t;
}
extern "C" {
    pub fn netif_create_ip6_linklocal_address(netif: *mut netif, from_mac_48bit: u8_t);
}
extern "C" {
    pub fn netif_add_ip6_address(
        netif: *mut netif,
        ip6addr: *const ip6_addr_t,
        chosen_idx: *mut s8_t,
    ) -> err_t;
}
extern "C" {
    pub fn netif_name_to_index(name: *const ::std::os::raw::c_char) -> u8_t;
}
extern "C" {
    pub fn netif_index_to_name(
        idx: u8_t,
        name: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn netif_get_by_index(idx: u8_t) -> *mut netif;
}
#[doc = " @ingroup netif"]
#[doc = " Extended netif status callback (NSC) reasons flags."]
#[doc = " May be extended in the future!"]
pub type netif_nsc_reason_t = u16_t;
#[doc = " @ingroup netif"]
#[doc = " Argument supplied to netif_ext_callback_fn."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union netif_ext_callback_args_t {
    pub link_changed: netif_ext_callback_args_t_link_changed_s,
    pub status_changed: netif_ext_callback_args_t_status_changed_s,
    pub ipv4_changed: netif_ext_callback_args_t_ipv4_changed_s,
    pub ipv6_set: netif_ext_callback_args_t_ipv6_set_s,
    pub ipv6_addr_state_changed: netif_ext_callback_args_t_ipv6_addr_state_changed_s,
}
#[doc = " Args to LWIP_NSC_LINK_CHANGED callback"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netif_ext_callback_args_t_link_changed_s {
    #[doc = " 1: up; 0: down"]
    pub state: u8_t,
}
#[test]
fn bindgen_test_layout_netif_ext_callback_args_t_link_changed_s() {
    assert_eq!(
        ::std::mem::size_of::<netif_ext_callback_args_t_link_changed_s>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(netif_ext_callback_args_t_link_changed_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<netif_ext_callback_args_t_link_changed_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(netif_ext_callback_args_t_link_changed_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<netif_ext_callback_args_t_link_changed_s>())).state as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netif_ext_callback_args_t_link_changed_s),
            "::",
            stringify!(state)
        )
    );
}
#[doc = " Args to LWIP_NSC_STATUS_CHANGED callback"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netif_ext_callback_args_t_status_changed_s {
    #[doc = " 1: up; 0: down"]
    pub state: u8_t,
}
#[test]
fn bindgen_test_layout_netif_ext_callback_args_t_status_changed_s() {
    assert_eq!(
        ::std::mem::size_of::<netif_ext_callback_args_t_status_changed_s>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(netif_ext_callback_args_t_status_changed_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<netif_ext_callback_args_t_status_changed_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(netif_ext_callback_args_t_status_changed_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<netif_ext_callback_args_t_status_changed_s>())).state as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netif_ext_callback_args_t_status_changed_s),
            "::",
            stringify!(state)
        )
    );
}
#[doc = " Args to LWIP_NSC_IPV4_ADDRESS_CHANGED|LWIP_NSC_IPV4_GATEWAY_CHANGED|LWIP_NSC_IPV4_NETMASK_CHANGED|LWIP_NSC_IPV4_SETTINGS_CHANGED callback"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netif_ext_callback_args_t_ipv4_changed_s {
    #[doc = " Old IPv4 address"]
    pub old_address: *const ip_addr_t,
    pub old_netmask: *const ip_addr_t,
    pub old_gw: *const ip_addr_t,
}
#[test]
fn bindgen_test_layout_netif_ext_callback_args_t_ipv4_changed_s() {
    assert_eq!(
        ::std::mem::size_of::<netif_ext_callback_args_t_ipv4_changed_s>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(netif_ext_callback_args_t_ipv4_changed_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<netif_ext_callback_args_t_ipv4_changed_s>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(netif_ext_callback_args_t_ipv4_changed_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<netif_ext_callback_args_t_ipv4_changed_s>())).old_address
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netif_ext_callback_args_t_ipv4_changed_s),
            "::",
            stringify!(old_address)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<netif_ext_callback_args_t_ipv4_changed_s>())).old_netmask
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(netif_ext_callback_args_t_ipv4_changed_s),
            "::",
            stringify!(old_netmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<netif_ext_callback_args_t_ipv4_changed_s>())).old_gw as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(netif_ext_callback_args_t_ipv4_changed_s),
            "::",
            stringify!(old_gw)
        )
    );
}
#[doc = " Args to LWIP_NSC_IPV6_SET callback"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netif_ext_callback_args_t_ipv6_set_s {
    #[doc = " Index of changed IPv6 address"]
    pub addr_index: s8_t,
    #[doc = " Old IPv6 address"]
    pub old_address: *const ip_addr_t,
}
#[test]
fn bindgen_test_layout_netif_ext_callback_args_t_ipv6_set_s() {
    assert_eq!(
        ::std::mem::size_of::<netif_ext_callback_args_t_ipv6_set_s>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(netif_ext_callback_args_t_ipv6_set_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<netif_ext_callback_args_t_ipv6_set_s>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(netif_ext_callback_args_t_ipv6_set_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<netif_ext_callback_args_t_ipv6_set_s>())).addr_index as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netif_ext_callback_args_t_ipv6_set_s),
            "::",
            stringify!(addr_index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<netif_ext_callback_args_t_ipv6_set_s>())).old_address as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(netif_ext_callback_args_t_ipv6_set_s),
            "::",
            stringify!(old_address)
        )
    );
}
#[doc = " Args to LWIP_NSC_IPV6_ADDR_STATE_CHANGED callback"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netif_ext_callback_args_t_ipv6_addr_state_changed_s {
    #[doc = " Index of affected IPv6 address"]
    pub addr_index: s8_t,
    #[doc = " Old IPv6 address state"]
    pub old_state: u8_t,
    #[doc = " Affected IPv6 address"]
    pub address: *const ip_addr_t,
}
#[test]
fn bindgen_test_layout_netif_ext_callback_args_t_ipv6_addr_state_changed_s() {
    assert_eq!(
        ::std::mem::size_of::<netif_ext_callback_args_t_ipv6_addr_state_changed_s>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(netif_ext_callback_args_t_ipv6_addr_state_changed_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<netif_ext_callback_args_t_ipv6_addr_state_changed_s>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(netif_ext_callback_args_t_ipv6_addr_state_changed_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<netif_ext_callback_args_t_ipv6_addr_state_changed_s>()))
                .addr_index as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netif_ext_callback_args_t_ipv6_addr_state_changed_s),
            "::",
            stringify!(addr_index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<netif_ext_callback_args_t_ipv6_addr_state_changed_s>()))
                .old_state as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(netif_ext_callback_args_t_ipv6_addr_state_changed_s),
            "::",
            stringify!(old_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<netif_ext_callback_args_t_ipv6_addr_state_changed_s>())).address
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(netif_ext_callback_args_t_ipv6_addr_state_changed_s),
            "::",
            stringify!(address)
        )
    );
}
#[test]
fn bindgen_test_layout_netif_ext_callback_args_t() {
    assert_eq!(
        ::std::mem::size_of::<netif_ext_callback_args_t>(),
        24usize,
        concat!("Size of: ", stringify!(netif_ext_callback_args_t))
    );
    assert_eq!(
        ::std::mem::align_of::<netif_ext_callback_args_t>(),
        8usize,
        concat!("Alignment of ", stringify!(netif_ext_callback_args_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<netif_ext_callback_args_t>())).link_changed as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netif_ext_callback_args_t),
            "::",
            stringify!(link_changed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<netif_ext_callback_args_t>())).status_changed as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netif_ext_callback_args_t),
            "::",
            stringify!(status_changed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<netif_ext_callback_args_t>())).ipv4_changed as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netif_ext_callback_args_t),
            "::",
            stringify!(ipv4_changed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<netif_ext_callback_args_t>())).ipv6_set as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netif_ext_callback_args_t),
            "::",
            stringify!(ipv6_set)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<netif_ext_callback_args_t>())).ipv6_addr_state_changed
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netif_ext_callback_args_t),
            "::",
            stringify!(ipv6_addr_state_changed)
        )
    );
}
#[doc = " @ingroup netif"]
#[doc = " Function used for extended netif status callbacks"]
#[doc = " Note: When parsing reason argument, keep in mind that more reasons may be added in the future!"]
#[doc = " @param netif netif that is affected by change"]
#[doc = " @param reason change reason"]
#[doc = " @param args depends on reason, see reason description"]
pub type netif_ext_callback_fn = ::std::option::Option<
    unsafe extern "C" fn(
        netif: *mut netif,
        reason: netif_nsc_reason_t,
        args: *const netif_ext_callback_args_t,
    ),
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ip4_addr_packed {
    pub addr: u32_t,
}
#[test]
fn bindgen_test_layout_ip4_addr_packed() {
    assert_eq!(
        ::std::mem::size_of::<ip4_addr_packed>(),
        4usize,
        concat!("Size of: ", stringify!(ip4_addr_packed))
    );
    assert_eq!(
        ::std::mem::align_of::<ip4_addr_packed>(),
        1usize,
        concat!("Alignment of ", stringify!(ip4_addr_packed))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip4_addr_packed>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip4_addr_packed),
            "::",
            stringify!(addr)
        )
    );
}
pub type ip4_addr_p_t = ip4_addr_packed;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ip_hdr {
    pub _v_hl: u8_t,
    pub _tos: u8_t,
    pub _len: u16_t,
    pub _id: u16_t,
    pub _offset: u16_t,
    pub _ttl: u8_t,
    pub _proto: u8_t,
    pub _chksum: u16_t,
    pub src: ip4_addr_p_t,
    pub dest: ip4_addr_p_t,
}
#[test]
fn bindgen_test_layout_ip_hdr() {
    assert_eq!(
        ::std::mem::size_of::<ip_hdr>(),
        20usize,
        concat!("Size of: ", stringify!(ip_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(ip_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_hdr>()))._v_hl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_hdr),
            "::",
            stringify!(_v_hl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_hdr>()))._tos as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_hdr),
            "::",
            stringify!(_tos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_hdr>()))._len as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_hdr),
            "::",
            stringify!(_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_hdr>()))._id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_hdr),
            "::",
            stringify!(_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_hdr>()))._offset as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_hdr),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_hdr>()))._ttl as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_hdr),
            "::",
            stringify!(_ttl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_hdr>()))._proto as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_hdr),
            "::",
            stringify!(_proto)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_hdr>()))._chksum as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_hdr),
            "::",
            stringify!(_chksum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_hdr>())).src as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_hdr),
            "::",
            stringify!(src)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_hdr>())).dest as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_hdr),
            "::",
            stringify!(dest)
        )
    );
}
extern "C" {
    pub fn ip4_route(dest: *const ip4_addr_t) -> *mut netif;
}
extern "C" {
    pub fn ip4_input(p: *mut pbuf, inp: *mut netif) -> err_t;
}
extern "C" {
    pub fn ip4_output(
        p: *mut pbuf,
        src: *const ip4_addr_t,
        dest: *const ip4_addr_t,
        ttl: u8_t,
        tos: u8_t,
        proto: u8_t,
    ) -> err_t;
}
extern "C" {
    pub fn ip4_output_if(
        p: *mut pbuf,
        src: *const ip4_addr_t,
        dest: *const ip4_addr_t,
        ttl: u8_t,
        tos: u8_t,
        proto: u8_t,
        netif: *mut netif,
    ) -> err_t;
}
extern "C" {
    pub fn ip4_output_if_src(
        p: *mut pbuf,
        src: *const ip4_addr_t,
        dest: *const ip4_addr_t,
        ttl: u8_t,
        tos: u8_t,
        proto: u8_t,
        netif: *mut netif,
    ) -> err_t;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_addr_packed {
    pub addr: [u32_t; 4usize],
}
#[test]
fn bindgen_test_layout_ip6_addr_packed() {
    assert_eq!(
        ::std::mem::size_of::<ip6_addr_packed>(),
        16usize,
        concat!("Size of: ", stringify!(ip6_addr_packed))
    );
    assert_eq!(
        ::std::mem::align_of::<ip6_addr_packed>(),
        1usize,
        concat!("Alignment of ", stringify!(ip6_addr_packed))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip6_addr_packed>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_addr_packed),
            "::",
            stringify!(addr)
        )
    );
}
pub type ip6_addr_p_t = ip6_addr_packed;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_hdr {
    pub _v_tc_fl: u32_t,
    pub _plen: u16_t,
    pub _nexth: u8_t,
    pub _hoplim: u8_t,
    pub src: ip6_addr_p_t,
    pub dest: ip6_addr_p_t,
}
#[test]
fn bindgen_test_layout_ip6_hdr() {
    assert_eq!(
        ::std::mem::size_of::<ip6_hdr>(),
        40usize,
        concat!("Size of: ", stringify!(ip6_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<ip6_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(ip6_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip6_hdr>()))._v_tc_fl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_hdr),
            "::",
            stringify!(_v_tc_fl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip6_hdr>()))._plen as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_hdr),
            "::",
            stringify!(_plen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip6_hdr>()))._nexth as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_hdr),
            "::",
            stringify!(_nexth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip6_hdr>()))._hoplim as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_hdr),
            "::",
            stringify!(_hoplim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip6_hdr>())).src as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_hdr),
            "::",
            stringify!(src)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip6_hdr>())).dest as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_hdr),
            "::",
            stringify!(dest)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_opt_hdr {
    pub _opt_type: u8_t,
    pub _opt_dlen: u8_t,
}
#[test]
fn bindgen_test_layout_ip6_opt_hdr() {
    assert_eq!(
        ::std::mem::size_of::<ip6_opt_hdr>(),
        2usize,
        concat!("Size of: ", stringify!(ip6_opt_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<ip6_opt_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(ip6_opt_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip6_opt_hdr>()))._opt_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_opt_hdr),
            "::",
            stringify!(_opt_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip6_opt_hdr>()))._opt_dlen as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_opt_hdr),
            "::",
            stringify!(_opt_dlen)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_hbh_hdr {
    pub _nexth: u8_t,
    pub _hlen: u8_t,
}
#[test]
fn bindgen_test_layout_ip6_hbh_hdr() {
    assert_eq!(
        ::std::mem::size_of::<ip6_hbh_hdr>(),
        2usize,
        concat!("Size of: ", stringify!(ip6_hbh_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<ip6_hbh_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(ip6_hbh_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip6_hbh_hdr>()))._nexth as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_hbh_hdr),
            "::",
            stringify!(_nexth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip6_hbh_hdr>()))._hlen as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_hbh_hdr),
            "::",
            stringify!(_hlen)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_dest_hdr {
    pub _nexth: u8_t,
    pub _hlen: u8_t,
}
#[test]
fn bindgen_test_layout_ip6_dest_hdr() {
    assert_eq!(
        ::std::mem::size_of::<ip6_dest_hdr>(),
        2usize,
        concat!("Size of: ", stringify!(ip6_dest_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<ip6_dest_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(ip6_dest_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip6_dest_hdr>()))._nexth as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_dest_hdr),
            "::",
            stringify!(_nexth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip6_dest_hdr>()))._hlen as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_dest_hdr),
            "::",
            stringify!(_hlen)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_rout_hdr {
    pub _nexth: u8_t,
    pub _hlen: u8_t,
    pub _routing_type: u8_t,
    pub _segments_left: u8_t,
}
#[test]
fn bindgen_test_layout_ip6_rout_hdr() {
    assert_eq!(
        ::std::mem::size_of::<ip6_rout_hdr>(),
        4usize,
        concat!("Size of: ", stringify!(ip6_rout_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<ip6_rout_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(ip6_rout_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip6_rout_hdr>()))._nexth as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_rout_hdr),
            "::",
            stringify!(_nexth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip6_rout_hdr>()))._hlen as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_rout_hdr),
            "::",
            stringify!(_hlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip6_rout_hdr>()))._routing_type as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_rout_hdr),
            "::",
            stringify!(_routing_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip6_rout_hdr>()))._segments_left as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_rout_hdr),
            "::",
            stringify!(_segments_left)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_frag_hdr {
    pub _nexth: u8_t,
    pub reserved: u8_t,
    pub _fragment_offset: u16_t,
    pub _identification: u32_t,
}
#[test]
fn bindgen_test_layout_ip6_frag_hdr() {
    assert_eq!(
        ::std::mem::size_of::<ip6_frag_hdr>(),
        8usize,
        concat!("Size of: ", stringify!(ip6_frag_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<ip6_frag_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(ip6_frag_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip6_frag_hdr>()))._nexth as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_frag_hdr),
            "::",
            stringify!(_nexth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip6_frag_hdr>())).reserved as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_frag_hdr),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip6_frag_hdr>()))._fragment_offset as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_frag_hdr),
            "::",
            stringify!(_fragment_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip6_frag_hdr>()))._identification as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_frag_hdr),
            "::",
            stringify!(_identification)
        )
    );
}
extern "C" {
    pub fn ip6_route(src: *const ip6_addr_t, dest: *const ip6_addr_t) -> *mut netif;
}
extern "C" {
    pub fn ip6_select_source_address(
        netif: *mut netif,
        dest: *const ip6_addr_t,
    ) -> *const ip_addr_t;
}
extern "C" {
    pub fn ip6_input(p: *mut pbuf, inp: *mut netif) -> err_t;
}
extern "C" {
    pub fn ip6_output(
        p: *mut pbuf,
        src: *const ip6_addr_t,
        dest: *const ip6_addr_t,
        hl: u8_t,
        tc: u8_t,
        nexth: u8_t,
    ) -> err_t;
}
extern "C" {
    pub fn ip6_output_if(
        p: *mut pbuf,
        src: *const ip6_addr_t,
        dest: *const ip6_addr_t,
        hl: u8_t,
        tc: u8_t,
        nexth: u8_t,
        netif: *mut netif,
    ) -> err_t;
}
extern "C" {
    pub fn ip6_output_if_src(
        p: *mut pbuf,
        src: *const ip6_addr_t,
        dest: *const ip6_addr_t,
        hl: u8_t,
        tc: u8_t,
        nexth: u8_t,
        netif: *mut netif,
    ) -> err_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_pcb {
    pub local_ip: ip_addr_t,
    pub remote_ip: ip_addr_t,
    pub netif_idx: u8_t,
    pub so_options: u8_t,
    pub tos: u8_t,
    pub ttl: u8_t,
}
#[test]
fn bindgen_test_layout_ip_pcb() {
    assert_eq!(
        ::std::mem::size_of::<ip_pcb>(),
        52usize,
        concat!("Size of: ", stringify!(ip_pcb))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_pcb>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_pcb))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_pcb>())).local_ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_pcb),
            "::",
            stringify!(local_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_pcb>())).remote_ip as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_pcb),
            "::",
            stringify!(remote_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_pcb>())).netif_idx as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_pcb),
            "::",
            stringify!(netif_idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_pcb>())).so_options as *const _ as usize },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_pcb),
            "::",
            stringify!(so_options)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_pcb>())).tos as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_pcb),
            "::",
            stringify!(tos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_pcb>())).ttl as *const _ as usize },
        51usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_pcb),
            "::",
            stringify!(ttl)
        )
    );
}
#[doc = " Global variables of this module, kept in a struct for efficient access using base+index."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_globals {
    #[doc = " The interface that accepted the packet for the current callback invocation."]
    pub current_netif: *mut netif,
    #[doc = " The interface that received the packet for the current callback invocation."]
    pub current_input_netif: *mut netif,
    #[doc = " Header of the input packet currently being processed."]
    pub current_ip4_header: *const ip_hdr,
    #[doc = " Header of the input IPv6 packet currently being processed."]
    pub current_ip6_header: *mut ip6_hdr,
    #[doc = " Total header length of current_ip4/6_header (i.e. after this, the UDP/TCP header starts)"]
    pub current_ip_header_tot_len: u16_t,
    #[doc = " Source IP address of current_header"]
    pub current_iphdr_src: ip_addr_t,
    #[doc = " Destination IP address of current_header"]
    pub current_iphdr_dest: ip_addr_t,
}
#[test]
fn bindgen_test_layout_ip_globals() {
    assert_eq!(
        ::std::mem::size_of::<ip_globals>(),
        88usize,
        concat!("Size of: ", stringify!(ip_globals))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_globals>(),
        8usize,
        concat!("Alignment of ", stringify!(ip_globals))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_globals>())).current_netif as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_globals),
            "::",
            stringify!(current_netif)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_globals>())).current_input_netif as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_globals),
            "::",
            stringify!(current_input_netif)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_globals>())).current_ip4_header as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_globals),
            "::",
            stringify!(current_ip4_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_globals>())).current_ip6_header as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_globals),
            "::",
            stringify!(current_ip6_header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ip_globals>())).current_ip_header_tot_len as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_globals),
            "::",
            stringify!(current_ip_header_tot_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_globals>())).current_iphdr_src as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_globals),
            "::",
            stringify!(current_iphdr_src)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_globals>())).current_iphdr_dest as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_globals),
            "::",
            stringify!(current_iphdr_dest)
        )
    );
}
extern "C" {
    pub static mut ip_data: ip_globals;
}
extern "C" {
    pub fn ip_input(p: *mut pbuf, inp: *mut netif) -> err_t;
}
#[doc = " This is the standard ICMP header only that the u32_t data"]
#[doc = "  is split to two u16_t like ICMP echo needs it."]
#[doc = "  This header is also used for other ICMP types that do not"]
#[doc = "  use the data part."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct icmp_echo_hdr {
    pub type_: u8_t,
    pub code: u8_t,
    pub chksum: u16_t,
    pub id: u16_t,
    pub seqno: u16_t,
}
#[test]
fn bindgen_test_layout_icmp_echo_hdr() {
    assert_eq!(
        ::std::mem::size_of::<icmp_echo_hdr>(),
        8usize,
        concat!("Size of: ", stringify!(icmp_echo_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<icmp_echo_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(icmp_echo_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icmp_echo_hdr>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(icmp_echo_hdr),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icmp_echo_hdr>())).code as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(icmp_echo_hdr),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icmp_echo_hdr>())).chksum as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(icmp_echo_hdr),
            "::",
            stringify!(chksum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icmp_echo_hdr>())).id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(icmp_echo_hdr),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icmp_echo_hdr>())).seqno as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(icmp_echo_hdr),
            "::",
            stringify!(seqno)
        )
    );
}
#[doc = " Destination unreachable"]
pub const icmp6_type_ICMP6_TYPE_DUR: icmp6_type = 1;
#[doc = " Packet too big"]
pub const icmp6_type_ICMP6_TYPE_PTB: icmp6_type = 2;
#[doc = " Time exceeded"]
pub const icmp6_type_ICMP6_TYPE_TE: icmp6_type = 3;
#[doc = " Parameter problem"]
pub const icmp6_type_ICMP6_TYPE_PP: icmp6_type = 4;
#[doc = " Private experimentation"]
pub const icmp6_type_ICMP6_TYPE_PE1: icmp6_type = 100;
#[doc = " Private experimentation"]
pub const icmp6_type_ICMP6_TYPE_PE2: icmp6_type = 101;
#[doc = " Reserved for expansion of error messages"]
pub const icmp6_type_ICMP6_TYPE_RSV_ERR: icmp6_type = 127;
#[doc = " Echo request"]
pub const icmp6_type_ICMP6_TYPE_EREQ: icmp6_type = 128;
#[doc = " Echo reply"]
pub const icmp6_type_ICMP6_TYPE_EREP: icmp6_type = 129;
#[doc = " Multicast listener query"]
pub const icmp6_type_ICMP6_TYPE_MLQ: icmp6_type = 130;
#[doc = " Multicast listener report"]
pub const icmp6_type_ICMP6_TYPE_MLR: icmp6_type = 131;
#[doc = " Multicast listener done"]
pub const icmp6_type_ICMP6_TYPE_MLD: icmp6_type = 132;
#[doc = " Router solicitation"]
pub const icmp6_type_ICMP6_TYPE_RS: icmp6_type = 133;
#[doc = " Router advertisement"]
pub const icmp6_type_ICMP6_TYPE_RA: icmp6_type = 134;
#[doc = " Neighbor solicitation"]
pub const icmp6_type_ICMP6_TYPE_NS: icmp6_type = 135;
#[doc = " Neighbor advertisement"]
pub const icmp6_type_ICMP6_TYPE_NA: icmp6_type = 136;
#[doc = " Redirect"]
pub const icmp6_type_ICMP6_TYPE_RD: icmp6_type = 137;
#[doc = " Multicast router advertisement"]
pub const icmp6_type_ICMP6_TYPE_MRA: icmp6_type = 151;
#[doc = " Multicast router solicitation"]
pub const icmp6_type_ICMP6_TYPE_MRS: icmp6_type = 152;
#[doc = " Multicast router termination"]
pub const icmp6_type_ICMP6_TYPE_MRT: icmp6_type = 153;
#[doc = " Private experimentation"]
pub const icmp6_type_ICMP6_TYPE_PE3: icmp6_type = 200;
#[doc = " Private experimentation"]
pub const icmp6_type_ICMP6_TYPE_PE4: icmp6_type = 201;
#[doc = " Reserved for expansion of informational messages"]
pub const icmp6_type_ICMP6_TYPE_RSV_INF: icmp6_type = 255;
#[doc = " ICMP type"]
pub type icmp6_type = ::std::os::raw::c_uint;
#[doc = " No route to destination"]
pub const icmp6_dur_code_ICMP6_DUR_NO_ROUTE: icmp6_dur_code = 0;
#[doc = " Communication with destination administratively prohibited"]
pub const icmp6_dur_code_ICMP6_DUR_PROHIBITED: icmp6_dur_code = 1;
#[doc = " Beyond scope of source address"]
pub const icmp6_dur_code_ICMP6_DUR_SCOPE: icmp6_dur_code = 2;
#[doc = " Address unreachable"]
pub const icmp6_dur_code_ICMP6_DUR_ADDRESS: icmp6_dur_code = 3;
#[doc = " Port unreachable"]
pub const icmp6_dur_code_ICMP6_DUR_PORT: icmp6_dur_code = 4;
#[doc = " Source address failed ingress/egress policy"]
pub const icmp6_dur_code_ICMP6_DUR_POLICY: icmp6_dur_code = 5;
#[doc = " Reject route to destination"]
pub const icmp6_dur_code_ICMP6_DUR_REJECT_ROUTE: icmp6_dur_code = 6;
#[doc = " ICMP destination unreachable codes"]
pub type icmp6_dur_code = ::std::os::raw::c_uint;
#[doc = " Hop limit exceeded in transit"]
pub const icmp6_te_code_ICMP6_TE_HL: icmp6_te_code = 0;
#[doc = " Fragment reassembly time exceeded"]
pub const icmp6_te_code_ICMP6_TE_FRAG: icmp6_te_code = 1;
#[doc = " ICMP time exceeded codes"]
pub type icmp6_te_code = ::std::os::raw::c_uint;
#[doc = " Erroneous header field encountered"]
pub const icmp6_pp_code_ICMP6_PP_FIELD: icmp6_pp_code = 0;
#[doc = " Unrecognized next header type encountered"]
pub const icmp6_pp_code_ICMP6_PP_HEADER: icmp6_pp_code = 1;
#[doc = " Unrecognized IPv6 option encountered"]
pub const icmp6_pp_code_ICMP6_PP_OPTION: icmp6_pp_code = 2;
#[doc = " ICMP parameter code"]
pub type icmp6_pp_code = ::std::os::raw::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct icmp6_hdr {
    pub type_: u8_t,
    pub code: u8_t,
    pub chksum: u16_t,
    pub data: u32_t,
}
#[test]
fn bindgen_test_layout_icmp6_hdr() {
    assert_eq!(
        ::std::mem::size_of::<icmp6_hdr>(),
        8usize,
        concat!("Size of: ", stringify!(icmp6_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<icmp6_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(icmp6_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icmp6_hdr>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(icmp6_hdr),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icmp6_hdr>())).code as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(icmp6_hdr),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icmp6_hdr>())).chksum as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(icmp6_hdr),
            "::",
            stringify!(chksum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icmp6_hdr>())).data as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(icmp6_hdr),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct icmp6_echo_hdr {
    pub type_: u8_t,
    pub code: u8_t,
    pub chksum: u16_t,
    pub id: u16_t,
    pub seqno: u16_t,
}
#[test]
fn bindgen_test_layout_icmp6_echo_hdr() {
    assert_eq!(
        ::std::mem::size_of::<icmp6_echo_hdr>(),
        8usize,
        concat!("Size of: ", stringify!(icmp6_echo_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<icmp6_echo_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(icmp6_echo_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icmp6_echo_hdr>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(icmp6_echo_hdr),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icmp6_echo_hdr>())).code as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(icmp6_echo_hdr),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icmp6_echo_hdr>())).chksum as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(icmp6_echo_hdr),
            "::",
            stringify!(chksum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icmp6_echo_hdr>())).id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(icmp6_echo_hdr),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icmp6_echo_hdr>())).seqno as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(icmp6_echo_hdr),
            "::",
            stringify!(seqno)
        )
    );
}
extern "C" {
    pub fn icmp6_input(p: *mut pbuf, inp: *mut netif);
}
extern "C" {
    pub fn icmp6_dest_unreach(p: *mut pbuf, c: icmp6_dur_code);
}
extern "C" {
    pub fn icmp6_packet_too_big(p: *mut pbuf, mtu: u32_t);
}
extern "C" {
    pub fn icmp6_time_exceeded(p: *mut pbuf, c: icmp6_te_code);
}
extern "C" {
    pub fn icmp6_time_exceeded_with_addrs(
        p: *mut pbuf,
        c: icmp6_te_code,
        src_addr: *const ip6_addr_t,
        dest_addr: *const ip6_addr_t,
    );
}
extern "C" {
    pub fn icmp6_param_problem(
        p: *mut pbuf,
        c: icmp6_pp_code,
        pointer: *const ::std::os::raw::c_void,
    );
}
#[doc = " net unreachable"]
pub const icmp_dur_type_ICMP_DUR_NET: icmp_dur_type = 0;
#[doc = " host unreachable"]
pub const icmp_dur_type_ICMP_DUR_HOST: icmp_dur_type = 1;
#[doc = " protocol unreachable"]
pub const icmp_dur_type_ICMP_DUR_PROTO: icmp_dur_type = 2;
#[doc = " port unreachable"]
pub const icmp_dur_type_ICMP_DUR_PORT: icmp_dur_type = 3;
#[doc = " fragmentation needed and DF set"]
pub const icmp_dur_type_ICMP_DUR_FRAG: icmp_dur_type = 4;
#[doc = " source route failed"]
pub const icmp_dur_type_ICMP_DUR_SR: icmp_dur_type = 5;
#[doc = " ICMP destination unreachable codes"]
pub type icmp_dur_type = ::std::os::raw::c_uint;
#[doc = " time to live exceeded in transit"]
pub const icmp_te_type_ICMP_TE_TTL: icmp_te_type = 0;
#[doc = " fragment reassembly time exceeded"]
pub const icmp_te_type_ICMP_TE_FRAG: icmp_te_type = 1;
#[doc = " ICMP time exceeded codes"]
pub type icmp_te_type = ::std::os::raw::c_uint;
extern "C" {
    pub fn icmp_input(p: *mut pbuf, inp: *mut netif);
}
extern "C" {
    pub fn icmp_dest_unreach(p: *mut pbuf, t: icmp_dur_type);
}
extern "C" {
    pub fn icmp_time_exceeded(p: *mut pbuf, t: icmp_te_type);
}
#[doc = " Function prototype for tcp accept callback functions. Called when a new"]
#[doc = " connection can be accepted on a listening pcb."]
#[doc = ""]
#[doc = " @param arg Additional argument to pass to the callback function (@see tcp_arg())"]
#[doc = " @param newpcb The new connection pcb"]
#[doc = " @param err An error code if there has been an error accepting."]
#[doc = "            Only return ERR_ABRT if you have called tcp_abort from within the"]
#[doc = "            callback function!"]
pub type tcp_accept_fn = ::std::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::std::os::raw::c_void,
        newpcb: *mut tcp_pcb,
        err: err_t,
    ) -> err_t,
>;
#[doc = " Function prototype for tcp receive callback functions. Called when data has"]
#[doc = " been received."]
#[doc = ""]
#[doc = " @param arg Additional argument to pass to the callback function (@see tcp_arg())"]
#[doc = " @param tpcb The connection pcb which received data"]
#[doc = " @param p The received data (or NULL when the connection has been closed!)"]
#[doc = " @param err An error code if there has been an error receiving"]
#[doc = "            Only return ERR_ABRT if you have called tcp_abort from within the"]
#[doc = "            callback function!"]
pub type tcp_recv_fn = ::std::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::std::os::raw::c_void,
        tpcb: *mut tcp_pcb,
        p: *mut pbuf,
        err: err_t,
    ) -> err_t,
>;
#[doc = " Function prototype for tcp sent callback functions. Called when sent data has"]
#[doc = " been acknowledged by the remote side. Use it to free corresponding resources."]
#[doc = " This also means that the pcb has now space available to send new data."]
#[doc = ""]
#[doc = " @param arg Additional argument to pass to the callback function (@see tcp_arg())"]
#[doc = " @param tpcb The connection pcb for which data has been acknowledged"]
#[doc = " @param len The amount of bytes acknowledged"]
#[doc = " @return ERR_OK: try to send some data by calling tcp_output"]
#[doc = "            Only return ERR_ABRT if you have called tcp_abort from within the"]
#[doc = "            callback function!"]
pub type tcp_sent_fn = ::std::option::Option<
    unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void, tpcb: *mut tcp_pcb, len: u16_t) -> err_t,
>;
#[doc = " Function prototype for tcp poll callback functions. Called periodically as"]
#[doc = " specified by @see tcp_poll."]
#[doc = ""]
#[doc = " @param arg Additional argument to pass to the callback function (@see tcp_arg())"]
#[doc = " @param tpcb tcp pcb"]
#[doc = " @return ERR_OK: try to send some data by calling tcp_output"]
#[doc = "            Only return ERR_ABRT if you have called tcp_abort from within the"]
#[doc = "            callback function!"]
pub type tcp_poll_fn = ::std::option::Option<
    unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void, tpcb: *mut tcp_pcb) -> err_t,
>;
#[doc = " Function prototype for tcp error callback functions. Called when the pcb"]
#[doc = " receives a RST or is unexpectedly closed for any other reason."]
#[doc = ""]
#[doc = " @note The corresponding pcb is already freed when this callback is called!"]
#[doc = ""]
#[doc = " @param arg Additional argument to pass to the callback function (@see tcp_arg())"]
#[doc = " @param err Error code to indicate why the pcb has been closed"]
#[doc = "            ERR_ABRT: aborted through tcp_abort or by a TCP timer"]
#[doc = "            ERR_RST: the connection was reset by the remote host"]
pub type tcp_err_fn =
    ::std::option::Option<unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void, err: err_t)>;
#[doc = " Function prototype for tcp connected callback functions. Called when a pcb"]
#[doc = " is connected to the remote side after initiating a connection attempt by"]
#[doc = " calling tcp_connect()."]
#[doc = ""]
#[doc = " @param arg Additional argument to pass to the callback function (@see tcp_arg())"]
#[doc = " @param tpcb The connection pcb which is connected"]
#[doc = " @param err An unused error code, always ERR_OK currently ;-) @todo!"]
#[doc = "            Only return ERR_ABRT if you have called tcp_abort from within the"]
#[doc = "            callback function!"]
#[doc = ""]
#[doc = " @note When a connection attempt fails, the error callback is currently called!"]
pub type tcp_connected_fn = ::std::option::Option<
    unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void, tpcb: *mut tcp_pcb, err: err_t) -> err_t,
>;
#[doc = " Function prototype for deallocation of arguments. Called *just before* the"]
#[doc = " pcb is freed, so don't expect to be able to do anything with this pcb!"]
#[doc = ""]
#[doc = " @param id ext arg id (allocated via @ref tcp_ext_arg_alloc_id)"]
#[doc = " @param data pointer to the data (set via @ref tcp_ext_arg_set before)"]
pub type tcp_extarg_callback_pcb_destroyed_fn =
    ::std::option::Option<unsafe extern "C" fn(id: u8_t, data: *mut ::std::os::raw::c_void)>;
#[doc = " Function prototype to transition arguments from a listening pcb to an accepted pcb"]
#[doc = ""]
#[doc = " @param id ext arg id (allocated via @ref tcp_ext_arg_alloc_id)"]
#[doc = " @param lpcb the listening pcb accepting a connection"]
#[doc = " @param cpcb the newly allocated connection pcb"]
#[doc = " @return ERR_OK if OK, any error if connection should be dropped"]
pub type tcp_extarg_callback_passive_open_fn = ::std::option::Option<
    unsafe extern "C" fn(id: u8_t, lpcb: *mut tcp_pcb_listen, cpcb: *mut tcp_pcb) -> err_t,
>;
#[doc = " A table of callback functions that is invoked for ext arguments"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_ext_arg_callbacks {
    #[doc = " @ref tcp_extarg_callback_pcb_destroyed_fn"]
    pub destroy: tcp_extarg_callback_pcb_destroyed_fn,
    #[doc = " @ref tcp_extarg_callback_passive_open_fn"]
    pub passive_open: tcp_extarg_callback_passive_open_fn,
}
#[test]
fn bindgen_test_layout_tcp_ext_arg_callbacks() {
    assert_eq!(
        ::std::mem::size_of::<tcp_ext_arg_callbacks>(),
        16usize,
        concat!("Size of: ", stringify!(tcp_ext_arg_callbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<tcp_ext_arg_callbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(tcp_ext_arg_callbacks))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_ext_arg_callbacks>())).destroy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_ext_arg_callbacks),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcp_ext_arg_callbacks>())).passive_open as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_ext_arg_callbacks),
            "::",
            stringify!(passive_open)
        )
    );
}
pub type tcpflags_t = u16_t;
#[doc = " the TCP protocol control block for listening pcbs"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcp_pcb_listen {
    pub local_ip: ip_addr_t,
    pub remote_ip: ip_addr_t,
    pub netif_idx: u8_t,
    pub so_options: u8_t,
    pub tos: u8_t,
    pub ttl: u8_t,
    pub next: *mut tcp_pcb_listen,
    pub callback_arg: *mut ::std::os::raw::c_void,
    pub state: tcp_state,
    pub prio: u8_t,
    pub local_port: u16_t,
    pub accept: tcp_accept_fn,
}
#[test]
fn bindgen_test_layout_tcp_pcb_listen() {
    assert_eq!(
        ::std::mem::size_of::<tcp_pcb_listen>(),
        88usize,
        concat!("Size of: ", stringify!(tcp_pcb_listen))
    );
    assert_eq!(
        ::std::mem::align_of::<tcp_pcb_listen>(),
        8usize,
        concat!("Alignment of ", stringify!(tcp_pcb_listen))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb_listen>())).local_ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb_listen),
            "::",
            stringify!(local_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb_listen>())).remote_ip as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb_listen),
            "::",
            stringify!(remote_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb_listen>())).netif_idx as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb_listen),
            "::",
            stringify!(netif_idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb_listen>())).so_options as *const _ as usize },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb_listen),
            "::",
            stringify!(so_options)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb_listen>())).tos as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb_listen),
            "::",
            stringify!(tos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb_listen>())).ttl as *const _ as usize },
        51usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb_listen),
            "::",
            stringify!(ttl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb_listen>())).next as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb_listen),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb_listen>())).callback_arg as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb_listen),
            "::",
            stringify!(callback_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb_listen>())).state as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb_listen),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb_listen>())).prio as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb_listen),
            "::",
            stringify!(prio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb_listen>())).local_port as *const _ as usize },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb_listen),
            "::",
            stringify!(local_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb_listen>())).accept as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb_listen),
            "::",
            stringify!(accept)
        )
    );
}
#[doc = " the TCP protocol control block"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcp_pcb {
    pub local_ip: ip_addr_t,
    pub remote_ip: ip_addr_t,
    pub netif_idx: u8_t,
    pub so_options: u8_t,
    pub tos: u8_t,
    pub ttl: u8_t,
    pub next: *mut tcp_pcb,
    pub callback_arg: *mut ::std::os::raw::c_void,
    pub state: tcp_state,
    pub prio: u8_t,
    pub local_port: u16_t,
    pub remote_port: u16_t,
    pub flags: tcpflags_t,
    pub polltmr: u8_t,
    pub pollinterval: u8_t,
    pub last_timer: u8_t,
    pub tmr: u32_t,
    pub rcv_nxt: u32_t,
    pub rcv_wnd: tcpwnd_size_t,
    pub rcv_ann_wnd: tcpwnd_size_t,
    pub rcv_ann_right_edge: u32_t,
    pub rtime: s16_t,
    pub mss: u16_t,
    pub rttest: u32_t,
    pub rtseq: u32_t,
    pub sa: s16_t,
    pub sv: s16_t,
    pub rto: s16_t,
    pub nrtx: u8_t,
    pub dupacks: u8_t,
    pub lastack: u32_t,
    pub cwnd: tcpwnd_size_t,
    pub ssthresh: tcpwnd_size_t,
    pub rto_end: u32_t,
    pub snd_nxt: u32_t,
    pub snd_wl1: u32_t,
    pub snd_wl2: u32_t,
    pub snd_lbb: u32_t,
    pub snd_wnd: tcpwnd_size_t,
    pub snd_wnd_max: tcpwnd_size_t,
    pub snd_buf: tcpwnd_size_t,
    pub snd_queuelen: u16_t,
    pub unsent_oversize: u16_t,
    pub bytes_acked: tcpwnd_size_t,
    pub unsent: *mut tcp_seg,
    pub unacked: *mut tcp_seg,
    pub ooseq: *mut tcp_seg,
    pub refused_data: *mut pbuf,
    pub listener: *mut tcp_pcb_listen,
    pub sent: tcp_sent_fn,
    pub recv: tcp_recv_fn,
    pub connected: tcp_connected_fn,
    pub poll: tcp_poll_fn,
    pub errf: tcp_err_fn,
    pub keep_idle: u32_t,
    pub persist_cnt: u8_t,
    pub persist_backoff: u8_t,
    pub persist_probe: u8_t,
    pub keep_cnt_sent: u8_t,
}
#[test]
fn bindgen_test_layout_tcp_pcb() {
    assert_eq!(
        ::std::mem::size_of::<tcp_pcb>(),
        256usize,
        concat!("Size of: ", stringify!(tcp_pcb))
    );
    assert_eq!(
        ::std::mem::align_of::<tcp_pcb>(),
        8usize,
        concat!("Alignment of ", stringify!(tcp_pcb))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).local_ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(local_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).remote_ip as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(remote_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).netif_idx as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(netif_idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).so_options as *const _ as usize },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(so_options)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).tos as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(tos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).ttl as *const _ as usize },
        51usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(ttl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).next as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).callback_arg as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(callback_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).state as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).prio as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(prio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).local_port as *const _ as usize },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(local_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).remote_port as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(remote_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).flags as *const _ as usize },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).polltmr as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(polltmr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).pollinterval as *const _ as usize },
        85usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(pollinterval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).last_timer as *const _ as usize },
        86usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(last_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).tmr as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(tmr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).rcv_nxt as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(rcv_nxt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).rcv_wnd as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(rcv_wnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).rcv_ann_wnd as *const _ as usize },
        98usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(rcv_ann_wnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).rcv_ann_right_edge as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(rcv_ann_right_edge)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).rtime as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(rtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).mss as *const _ as usize },
        106usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(mss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).rttest as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(rttest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).rtseq as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(rtseq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).sa as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(sa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).sv as *const _ as usize },
        118usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(sv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).rto as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(rto)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).nrtx as *const _ as usize },
        122usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(nrtx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).dupacks as *const _ as usize },
        123usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(dupacks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).lastack as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(lastack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).cwnd as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(cwnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).ssthresh as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(ssthresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).rto_end as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(rto_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).snd_nxt as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(snd_nxt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).snd_wl1 as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(snd_wl1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).snd_wl2 as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(snd_wl2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).snd_lbb as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(snd_lbb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).snd_wnd as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(snd_wnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).snd_wnd_max as *const _ as usize },
        154usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(snd_wnd_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).snd_buf as *const _ as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(snd_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).snd_queuelen as *const _ as usize },
        158usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(snd_queuelen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).unsent_oversize as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(unsent_oversize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).bytes_acked as *const _ as usize },
        162usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(bytes_acked)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).unsent as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(unsent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).unacked as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(unacked)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).ooseq as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(ooseq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).refused_data as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(refused_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).listener as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(listener)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).sent as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(sent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).recv as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(recv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).connected as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(connected)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).poll as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(poll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).errf as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(errf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).keep_idle as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(keep_idle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).persist_cnt as *const _ as usize },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(persist_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).persist_backoff as *const _ as usize },
        253usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(persist_backoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).persist_probe as *const _ as usize },
        254usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(persist_probe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_pcb>())).keep_cnt_sent as *const _ as usize },
        255usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_pcb),
            "::",
            stringify!(keep_cnt_sent)
        )
    );
}
extern "C" {
    pub fn tcp_new() -> *mut tcp_pcb;
}
extern "C" {
    pub fn tcp_new_ip_type(type_: u8_t) -> *mut tcp_pcb;
}
extern "C" {
    pub fn tcp_arg(pcb: *mut tcp_pcb, arg: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn tcp_recv(pcb: *mut tcp_pcb, recv: tcp_recv_fn);
}
extern "C" {
    pub fn tcp_sent(pcb: *mut tcp_pcb, sent: tcp_sent_fn);
}
extern "C" {
    pub fn tcp_err(pcb: *mut tcp_pcb, err: tcp_err_fn);
}
extern "C" {
    pub fn tcp_accept(pcb: *mut tcp_pcb, accept: tcp_accept_fn);
}
extern "C" {
    pub fn tcp_poll(pcb: *mut tcp_pcb, poll: tcp_poll_fn, interval: u8_t);
}
extern "C" {
    pub fn tcp_recved(pcb: *mut tcp_pcb, len: u16_t);
}
extern "C" {
    pub fn tcp_bind(pcb: *mut tcp_pcb, ipaddr: *const ip_addr_t, port: u16_t) -> err_t;
}
extern "C" {
    pub fn tcp_bind_netif(pcb: *mut tcp_pcb, netif: *const netif);
}
extern "C" {
    pub fn tcp_connect(
        pcb: *mut tcp_pcb,
        ipaddr: *const ip_addr_t,
        port: u16_t,
        connected: tcp_connected_fn,
    ) -> err_t;
}
extern "C" {
    pub fn tcp_listen_with_backlog_and_err(
        pcb: *mut tcp_pcb,
        backlog: u8_t,
        err: *mut err_t,
    ) -> *mut tcp_pcb;
}
extern "C" {
    pub fn tcp_listen_with_backlog(pcb: *mut tcp_pcb, backlog: u8_t) -> *mut tcp_pcb;
}
extern "C" {
    pub fn tcp_abort(pcb: *mut tcp_pcb);
}
extern "C" {
    pub fn tcp_close(pcb: *mut tcp_pcb) -> err_t;
}
extern "C" {
    pub fn tcp_shutdown(
        pcb: *mut tcp_pcb,
        shut_rx: ::std::os::raw::c_int,
        shut_tx: ::std::os::raw::c_int,
    ) -> err_t;
}
extern "C" {
    pub fn tcp_write(
        pcb: *mut tcp_pcb,
        dataptr: *const ::std::os::raw::c_void,
        len: u16_t,
        apiflags: u8_t,
    ) -> err_t;
}
extern "C" {
    pub fn tcp_setprio(pcb: *mut tcp_pcb, prio: u8_t);
}
extern "C" {
    pub fn tcp_output(pcb: *mut tcp_pcb) -> err_t;
}
extern "C" {
    pub fn tcp_tcp_get_tcp_addrinfo(
        pcb: *mut tcp_pcb,
        local: ::std::os::raw::c_int,
        addr: *mut ip_addr_t,
        port: *mut u16_t,
    ) -> err_t;
}
pub type __uint128_t = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_seg {
    pub _address: u8,
}
